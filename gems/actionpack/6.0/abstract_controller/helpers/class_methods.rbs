# !!! GENERATED CODE !!!
# Please see generators/rails-generator

module AbstractController::Helpers::ClassMethods
  # When a class is inherited, wrap its helper module in a new module.
  # This ensures that the parent class's module can be changed
  # independently of the child class's.
  def inherited: (untyped klass) -> untyped
  # Declare a controller method as a helper. For example, the following
  # makes the +current_user+ and +logged_in?+ controller methods available
  # to the view:
  #   class ApplicationController < ActionController::Base
  #     helper_method :current_user, :logged_in?
  #
  #     def current_user
  #       @current_user ||= User.find_by(id: session[:user])
  #     end
  #
  #     def logged_in?
  #       current_user != nil
  #     end
  #   end
  #
  # In a view:
  #  <% if logged_in? -%>Welcome, <%= current_user.name %><% end -%>
  #
  # ==== Parameters
  # * <tt>method[, method]</tt> - A name or names of a method on the controller
  #   to be made available on the view.
  def helper_method: (*untyped meths) -> untyped
  # The +helper+ class method can take a series of helper module names, a block, or both.
  #
  # ==== Options
  # * <tt>*args</tt> - Module, Symbol, String
  # * <tt>block</tt> - A block defining helper methods
  #
  # When the argument is a module it will be included directly in the template class.
  #   helper FooHelper # => includes FooHelper
  #
  # When the argument is a string or symbol, the method will provide the "_helper" suffix, require the file
  # and include the module in the template class. The second form illustrates how to include custom helpers
  # when working with namespaced controllers, or other cases where the file containing the helper definition is not
  # in one of Rails' standard load paths:
  #   helper :foo             # => requires 'foo_helper' and includes FooHelper
  #   helper 'resources/foo'  # => requires 'resources/foo_helper' and includes Resources::FooHelper
  #
  # Additionally, the +helper+ class method can receive and evaluate a block, making the methods defined available
  # to the template.
  #
  #   # One line
  #   helper { def hello() "Hello, world!" end }
  #
  #   # Multi-line
  #   helper do
  #     def foo(bar)
  #       "#{bar} is the very best"
  #     end
  #   end
  #
  # Finally, all the above styles can be mixed together, and the +helper+ method can be invoked with a mix of
  # +symbols+, +strings+, +modules+ and blocks.
  #
  #   helper(:three, BlindHelper) { def mice() 'mice' end }
  #
  def helper: (*untyped args) ?{ () -> untyped } -> untyped
  # Clears up all existing helpers in this class, only keeping the helper
  # with the same name as this class.
  def clear_helpers: () -> untyped
  # Returns a list of modules, normalized from the acceptable kinds of
  # helpers with the following behavior:
  #
  # String or Symbol:: :FooBar or "FooBar" becomes "foo_bar_helper",
  # and "foo_bar_helper.rb" is loaded using require_dependency.
  #
  # Module:: No further processing
  #
  # After loading the appropriate files, the corresponding modules
  # are returned.
  #
  # ==== Parameters
  # * <tt>args</tt> - An array of helpers
  #
  # ==== Returns
  # * <tt>Array</tt> - A normalized list of modules for the list of
  #   helpers provided.
  def modules_for_helpers: (untyped args) -> untyped
  # Makes all the (instance) methods in the helper module available to templates
  # rendered through this controller.
  #
  # ==== Parameters
  # * <tt>module</tt> - The module to include into the current helper module
  #   for the class
  private def add_template_helper: (untyped mod) -> untyped
  private def default_helper_module!: () -> untyped
end
