# !!! GENERATED CODE !!!
# Please see generators/rails-generator

class AbstractController::Base
  alias self.abstract? self.abstract
  # Define a controller as abstract. See internal_methods for more
  # details.
  def self.abstract!: () -> untyped
  def self.inherited: (untyped klass) -> untyped
  # A list of all internal methods for a controller. This finds the first
  # abstract superclass of a controller, and gets a list of all public
  # instance methods on that abstract class. Public instance methods of
  # a controller would normally be considered action methods, so methods
  # declared on abstract classes are being removed.
  # (<tt>ActionController::Metal</tt> and ActionController::Base are defined as abstract)
  def self.internal_methods: () -> untyped
  # A list of method names that should be considered actions. This
  # includes all public instance methods on a controller, less
  # any internal methods (see internal_methods), adding back in
  # any methods that are internal, but still exist on the class
  # itself.
  #
  # ==== Returns
  # * <tt>Set</tt> - A set of all methods that should be considered actions.
  def self.action_methods: () -> untyped
  # action_methods are cached and there is sometimes a need to refresh
  # them. ::clear_action_methods! allows you to do that, so next time
  # you run action_methods, they will be recalculated.
  def self.clear_action_methods!: () -> untyped
  # Returns the full controller name, underscored, without the ending Controller.
  #
  #   class MyApp::MyPostsController < AbstractController::Base
  #
  #   end
  #
  #   MyApp::MyPostsController.controller_path # => "my_app/my_posts"
  #
  # ==== Returns
  # * <tt>String</tt>
  def self.controller_path: () -> (untyped | nil)
  # Refresh the cached action_methods when a new action_method is added.
  def self.method_added: (untyped name) -> untyped
  # Calls the action going through the entire action dispatch stack.
  #
  # The actual method that is called is determined by calling
  # #method_for_action. If no method can handle the action, then an
  # AbstractController::ActionNotFound error is raised.
  #
  # ==== Returns
  # * <tt>self</tt>
  def process: (untyped action, *untyped args) -> untyped
  # Delegates to the class' ::controller_path
  def controller_path: () -> untyped
  # Delegates to the class' ::action_methods
  def action_methods: () -> untyped
  # Returns true if a method for the action is available and
  # can be dispatched, false otherwise.
  #
  # Notice that <tt>action_methods.include?("foo")</tt> may return
  # false and <tt>available_action?("foo")</tt> returns true because
  # this method considers actions that are also available
  # through other means, for example, implicit render ones.
  #
  # ==== Parameters
  # * <tt>action_name</tt> - The name of an action to be tested
  def available_action?: (untyped action_name) -> untyped
  # Tests if a response body is set. Used to determine if the
  # +process_action+ callback needs to be terminated in
  # +AbstractController::Callbacks+.
  def performed?: () -> untyped
  # Returns true if the given controller is capable of rendering
  # a path. A subclass of +AbstractController::Base+
  # may return false. An Email controller for example does not
  # support paths, only full URLs.
  def self.supports_path?: () -> true
  def inspect: () -> ::String
  # Returns true if the name can be considered an action because
  # it has a method defined in the controller.
  #
  # ==== Parameters
  # * <tt>name</tt> - The name of an action to be tested
  private def action_method?: (untyped name) -> untyped
  # Call the action. Override this in a subclass to modify the
  # behavior around processing an action. This, and not #process,
  # is the intended way to override action dispatching.
  #
  # Notice that the first argument is the method to be dispatched
  # which is *not* necessarily the same as the action name.
  private def process_action: (untyped method_name, *untyped args) -> untyped
  # Actually call the method associated with the action. Override
  # this method if you wish to change how action methods are called,
  # not to add additional behavior around it. For example, you would
  # override #send_action if you want to inject arguments into the
  # method.
  alias send_action send
  # If the action name was not found, but a method called "action_missing"
  # was found, #method_for_action will return "_handle_action_missing".
  # This method calls #action_missing with the current action name.
  private def _handle_action_missing: (*untyped args) -> untyped
  # Takes an action name and returns the name of the method that will
  # handle the action.
  #
  # It checks if the action name is valid and returns false otherwise.
  #
  # See method_for_action for more information.
  #
  # ==== Parameters
  # * <tt>action_name</tt> - An action name to find a method name for
  #
  # ==== Returns
  # * <tt>string</tt> - The name of the method that handles the action
  # * false           - No valid method name could be found.
  # Raise +AbstractController::ActionNotFound+.
  private def _find_action_name: (untyped action_name) -> untyped
  # Takes an action name and returns the name of the method that will
  # handle the action. In normal cases, this method returns the same
  # name as it receives. By default, if #method_for_action receives
  # a name that is not an action, it will look for an #action_missing
  # method and return "_handle_action_missing" if one is found.
  #
  # Subclasses may override this method to add additional conditions
  # that should be considered an action. For instance, an HTTP controller
  # with a template matching the action name is considered to exist.
  #
  # If you override this method to handle additional cases, you may
  # also provide a method (like +_handle_method_missing+) to handle
  # the case.
  #
  # If none of these conditions are true, and +method_for_action+
  # returns +nil+, an +AbstractController::ActionNotFound+ exception will be raised.
  #
  # ==== Parameters
  # * <tt>action_name</tt> - An action name to find a method name for
  #
  # ==== Returns
  # * <tt>string</tt> - The name of the method that handles the action
  # * <tt>nil</tt>    - No method name could be found.
  private def method_for_action: (untyped action_name) -> (untyped | "_handle_action_missing" | nil)
  # Checks if the action name is valid and returns false otherwise.
  private def _valid_action_name?: (untyped action_name) -> untyped
  include ActiveSupport::Configurable
  extend ActiveSupport::Configurable::ClassMethods
  extend ActiveSupport::DescendantsTracker
  attr_reader _response_body: untyped
  attr_reader _action_name: untyped
  attr_reader _formats: untyped
  attr_reader self.abstract: untyped
  attr_writer _response_body: untyped
  attr_writer _action_name: untyped
  attr_writer _formats: untyped
end
