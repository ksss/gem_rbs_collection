# !!! GENERATED CODE !!!
# Please see generators/rails-generator

module AbstractController::Helpers::ClassMethods
  # When a class is inherited, wrap its helper module in a new module.
  # This ensures that the parent class's module can be changed
  # independently of the child class's.
  def inherited: (untyped klass) -> untyped
  # Declare a controller method as a helper. For example, the following
  # makes the +current_user+ and +logged_in?+ controller methods available
  # to the view:
  #   class ApplicationController < ActionController::Base
  #     helper_method :current_user, :logged_in?
  #
  #     def current_user
  #       @current_user ||= User.find_by(id: session[:user])
  #     end
  #
  #     def logged_in?
  #       current_user != nil
  #     end
  #   end
  #
  # In a view:
  #  <% if logged_in? -%>Welcome, <%= current_user.name %><% end -%>
  #
  # ==== Parameters
  # * <tt>method[, method]</tt> - A name or names of a method on the controller
  #   to be made available on the view.
  def helper_method: (*untyped methods) -> untyped
  # Includes the given modules in the template class.
  #
  # Modules can be specified in different ways. All of the following calls
  # include +FooHelper+:
  #
  #   # Module, recommended.
  #   helper FooHelper
  #
  #   # String/symbol without the "helper" suffix, camel or snake case.
  #   helper "Foo"
  #   helper :Foo
  #   helper "foo"
  #   helper :foo
  #
  # The last two assume that <tt>"foo".camelize</tt> returns "Foo".
  #
  # When strings or symbols are passed, the method finds the actual module
  # object using +String#constantize+. Therefore, if the module has not been
  # yet loaded, it has to be autoloadable, which is normally the case.
  #
  # Namespaces are supported. The following calls include +Foo::BarHelper+:
  #
  #   # Module, recommended.
  #   helper Foo::BarHelper
  #
  #   # String/symbol without the "helper" suffix, camel or snake case.
  #   helper "Foo::Bar"
  #   helper :"Foo::Bar"
  #   helper "foo/bar"
  #   helper :"foo/bar"
  #
  # The last two assume that <tt>"foo/bar".camelize</tt> returns "Foo::Bar".
  #
  # The method accepts a block too. If present, the block is evaluated in
  # the context of the controller helper module. This simple call makes the
  # +wadus+ method available in templates of the enclosing controller:
  #
  #   helper do
  #     def wadus
  #       "wadus"
  #     end
  #   end
  #
  # Furthermore, all the above styles can be mixed together:
  #
  #   helper FooHelper, "woo", "bar/baz" do
  #     def wadus
  #       "wadus"
  #     end
  #   end
  #
  def helper: (*untyped args) ?{ () -> untyped } -> untyped
  # Clears up all existing helpers in this class, only keeping the helper
  # with the same name as this class.
  def clear_helpers: () -> untyped
  # Given an array of values like the ones accepted by +helper+, this method
  # returns an array with the corresponding modules, in the same order.
  def modules_for_helpers: (untyped modules_or_helper_prefixes) -> untyped
  def _helpers_for_modification: () -> untyped
  private def define_helpers_module: (untyped klass, ?untyped? helpers) -> untyped
  private def default_helper_module!: () -> untyped
  attr_writer _helpers: untyped
end
