# !!! GENERATED CODE !!!
# Please see generators/rails-generator

module ActionDispatch::Http::Cache::Response
  def last_modified: () -> (untyped | nil)
  def last_modified?: () -> untyped
  def last_modified=: (untyped utc_time) -> untyped
  def date: () -> (untyped | nil)
  def date?: () -> untyped
  def date=: (untyped utc_time) -> untyped
  # This method sets a weak ETag validator on the response so browsers
  # and proxies may cache the response, keyed on the ETag. On subsequent
  # requests, the If-None-Match header is set to the cached ETag. If it
  # matches the current ETag, we can return a 304 Not Modified response
  # with no body, letting the browser or proxy know that their cache is
  # current. Big savings in request time and network bandwidth.
  #
  # Weak ETags are considered to be semantically equivalent but not
  # byte-for-byte identical. This is perfect for browser caching of HTML
  # pages where we don't care about exact equality, just what the user
  # is viewing.
  #
  # Strong ETags are considered byte-for-byte identical. They allow a
  # browser or proxy cache to support Range requests, useful for paging
  # through a PDF file or scrubbing through a video. Some CDNs only
  # support strong ETags and will ignore weak ETags entirely.
  #
  # Weak ETags are what we almost always need, so they're the default.
  # Check out #strong_etag= to provide a strong ETag validator.
  def etag=: (untyped weak_validators) -> untyped
  def weak_etag=: (untyped weak_validators) -> untyped
  def strong_etag=: (untyped strong_validators) -> untyped
  def etag?: () -> untyped
  # True if an ETag is set and it's a weak validator (preceded with W/)
  def weak_etag?: () -> untyped
  # True if an ETag is set and it isn't a weak validator (not preceded with W/)
  def strong_etag?: () -> untyped
  private def generate_weak_etag: (untyped validators) -> ::String
  private def generate_strong_etag: (untyped validators) -> ::String
  private def cache_control_segments: () -> (untyped | ::Array[untyped])
  private def cache_control_headers: () -> untyped
  private def prepare_cache_control!: () -> untyped
  private def handle_conditional_get!: () -> (untyped | nil)
  private def merge_and_normalize_cache_control!: (untyped cache_control) -> (nil | untyped)
  attr_reader cache_control: untyped
  DATE: String
  DEFAULT_CACHE_CONTROL: String
  LAST_MODIFIED: String
  MUST_REVALIDATE: String
  NO_CACHE: String
  NO_STORE: String
  PRIVATE: String
  PUBLIC: String
  SPECIAL_KEYS: Set[String]
end
