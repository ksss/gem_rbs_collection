# !!! GENERATED CODE !!!
# Please see generators/rails-generator

module ActionDispatch::Http::MimeNegotiation
  # The MIME type of the HTTP request, such as Mime[:xml].
  def content_mime_type: () -> untyped
  def content_type: () -> untyped
  def has_content_type?: () -> untyped
  # Returns the accepted MIME type for the request.
  def accepts: () -> untyped
  # Returns the MIME type for the \format used in the request.
  #
  #   GET /posts/5.xml   | request.format => Mime[:xml]
  #   GET /posts/5.xhtml | request.format => Mime[:html]
  #   GET /posts/5       | request.format => Mime[:html] or Mime[:js], or request.accepts.first
  #
  def format: (?untyped view_path) -> untyped
  def formats: () -> untyped
  # Sets the \variant for template.
  def variant=: (untyped variant) -> untyped
  def variant: () -> untyped
  # Sets the \format by string extension, which can be used to force custom formats
  # that are not controlled by the extension.
  #
  #   class ApplicationController < ActionController::Base
  #     before_action :adjust_format_for_iphone
  #
  #     private
  #       def adjust_format_for_iphone
  #         request.format = :iphone if request.env["HTTP_USER_AGENT"][/iPhone/]
  #       end
  #   end
  def format=: (untyped extension) -> untyped
  # Sets the \formats by string extensions. This differs from #format= by allowing you
  # to set multiple, ordered formats, which is useful when you want to have a fallback.
  #
  # In this example, the +:iphone+ format will be used if it's available, otherwise it'll fallback
  # to the +:html+ format.
  #
  #   class ApplicationController < ActionController::Base
  #     before_action :adjust_format_for_iphone_with_html_fallback
  #
  #     private
  #       def adjust_format_for_iphone_with_html_fallback
  #         request.formats = [ :iphone, :html ] if request.env["HTTP_USER_AGENT"][/iPhone/]
  #       end
  #   end
  def formats=: (untyped extensions) -> untyped
  # Returns the first MIME type that matches the provided array of MIME types.
  def negotiate_mime: (untyped order) -> untyped
  def should_apply_vary_header?: () -> untyped
  private def params_readable?: () -> untyped
  private def valid_accept_header: () -> untyped
  private def use_accept_header: () -> untyped
  private def format_from_path_extension: () -> untyped
  extend ActiveSupport::Concern
  BROWSER_LIKE_ACCEPTS: Regexp
  RESCUABLE_MIME_FORMAT_ERRORS: Array[singleton(ActionController::BadRequest) | singleton(ActionDispatch::Http::Parameters::ParseError)]
end
