# !!! GENERATED CODE !!!
# Please see generators/rails-generator

class ActionView::Template
  def self.finalize_compiled_template_methods: () -> untyped
  def self.finalize_compiled_template_methods=: (untyped _) -> untyped
  def initialize: (untyped source, untyped identifier, untyped handler, ?format: untyped?, ?variant: untyped?, ?locals: untyped?, ?virtual_path: untyped?, ?updated_at: untyped?) -> void
  def virtual_path=: (untyped _) -> nil
  def locals=: (untyped _) -> nil
  def formats=: (untyped _) -> nil
  def formats: () -> untyped
  def variants=: (untyped _) -> nil
  def variants: () -> ::Array[untyped]
  def refresh: (untyped _) -> self
  # Returns whether the underlying handler supports streaming. If so,
  # a streaming buffer *may* be passed when it starts rendering.
  def supports_streaming?: () -> untyped
  # Render a template. If the template was not compiled yet, it is done
  # exactly before rendering.
  #
  # This method is instrumented as "!render_template.action_view". Notice that
  # we use a bang in this instrumentation because you don't want to
  # consume this in production. This is only slow if it's being listened to.
  def render: (untyped view, untyped locals, ?untyped buffer) ?{ () -> untyped } -> untyped
  def type: () -> untyped
  def short_identifier: () -> untyped
  def inspect: () -> ::String
  def source: () -> untyped
  # This method is responsible for properly setting the encoding of the
  # source. Until this point, we assume that the source is BINARY data.
  # If no additional information is supplied, we assume the encoding is
  # the same as <tt>Encoding.default_external</tt>.
  #
  # The user can also specify the encoding via a comment on the first
  # line of the template (# encoding: NAME-OF-ENCODING). This will work
  # with any template engine, as we process out the encoding comment
  # before passing the source on to the template engine, leaving a
  # blank line in its stead.
  def encode!: () -> untyped
  # Exceptions are marshalled when using the parallel test runner with DRb, so we need
  # to ensure that references to the template object can be marshalled as well. This means forgoing
  # the marshalling of the compiler mutex and instantiating that again on unmarshalling.
  def marshal_dump: () -> ::Array[untyped]
  def marshal_load: (untyped array) -> untyped
  # Compile a template. This method ensures a template is compiled
  # just once and removes the source after it is compiled.
  private def compile!: (untyped view) -> (nil | untyped)
  # Among other things, this method is responsible for properly setting
  # the encoding of the compiled template.
  #
  # If the template engine handles encodings, we send the encoded
  # String to the engine without further processing. This allows
  # the template engine to support additional mechanisms for
  # specifying the encoding. For instance, ERB supports <%# encoding: %>
  #
  # Otherwise, after we figure out the correct encoding, we then
  # encode the source into <tt>Encoding.default_internal</tt>.
  # In general, this means that templates will be UTF-8 inside of Rails,
  # regardless of the original source encoding.
  private def compile: (untyped mod) -> untyped
  private def handle_render_error: (untyped view, untyped e) -> untyped
  private def locals_code: () -> untyped
  private def method_name: () -> untyped
  private def identifier_method_name: () -> untyped
  private def instrument: (untyped action) ?{ () -> untyped } -> untyped
  private def instrument_render_template: () ?{ () -> untyped } -> untyped
  private def instrument_payload: () -> { virtual_path: untyped, identifier: untyped }
  extend ActiveSupport::Autoload
  extend ActionView::Template::Handlers
  attr_reader identifier: untyped
  attr_reader handler: untyped
  attr_reader original_encoding: untyped
  attr_reader updated_at: untyped
  attr_reader variable: untyped
  attr_reader format: untyped
  attr_reader variant: untyped
  attr_reader locals: untyped
  attr_reader virtual_path: untyped
end
