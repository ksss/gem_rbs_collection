# !!! GENERATED CODE !!!
# Please see generators/rails-generator

class ActionView::Helpers::FormBuilder
  def rich_text_area: (untyped method, ?::Hash[untyped, untyped] options) -> untyped
  # Wraps ActionView::Helpers::DateHelper#date_select for form builders:
  #
  #   <%= form_for @person do |f| %>
  #     <%= f.date_select :birth_date %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def date_select: (untyped method, ?::Hash[untyped, untyped] options, ?::Hash[untyped, untyped] html_options) -> untyped
  # Wraps ActionView::Helpers::DateHelper#time_select for form builders:
  #
  #   <%= form_for @race do |f| %>
  #     <%= f.time_select :average_lap %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def time_select: (untyped method, ?::Hash[untyped, untyped] options, ?::Hash[untyped, untyped] html_options) -> untyped
  # Wraps ActionView::Helpers::DateHelper#datetime_select for form builders:
  #
  #   <%= form_for @person do |f| %>
  #     <%= f.datetime_select :last_request_at %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def datetime_select: (untyped method, ?::Hash[untyped, untyped] options, ?::Hash[untyped, untyped] html_options) -> untyped
  alias multipart? multipart
  def multipart=: (untyped multipart) -> untyped
  def self._to_partial_path: () -> untyped
  def to_partial_path: () -> untyped
  def to_model: () -> self
  def initialize: (untyped object_name, untyped object, untyped template, untyped options) -> void
  # Generate an HTML <tt>id</tt> attribute value.
  #
  # return the <tt><form></tt> element's <tt>id</tt> attribute.
  #
  #   <%= form_for @post do |f| %>
  #     <%# ... %>
  #
  #     <% content_for :sticky_footer do %>
  #       <%= form.button(form: f.id) %>
  #     <% end %>
  #   <% end %>
  #
  # In the example above, the <tt>:sticky_footer</tt> content area will
  # exist outside of the <tt><form></tt> element. By declaring the
  # <tt>form</tt> HTML attribute, we hint to the browser that the generated
  # <tt><button></tt> element should be treated as the <tt><form></tt>
  # element's submit button, regardless of where it exists in the DOM.
  def id: () -> untyped
  # Generate an HTML <tt>id</tt> attribute value for the given field
  #
  # Return the value generated by the <tt>FormBuilder</tt> for the given
  # attribute name.
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.label :title %>
  #     <%= f.text_field :title, aria: { describedby: f.field_id(:title, :error) } %>
  #     <%= tag.span("is blank", id: f.field_id(:title, :error) %>
  #   <% end %>
  #
  # In the example above, the <tt><input type="text"></tt> element built by
  # the call to <tt>FormBuilder#text_field</tt> declares an
  # <tt>aria-describedby</tt> attribute referencing the <tt><span></tt>
  # element, sharing a common <tt>id</tt> root (<tt>post_title</tt>, in this
  # case).
  def field_id: (untyped method, *untyped suffixes, ?namespace: untyped, ?index: untyped) -> untyped
  # Generate an HTML <tt>name</tt> attribute value for the given name and
  # field combination
  #
  # Return the value generated by the <tt>FormBuilder</tt> for the given
  # attribute name.
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.text_field :title, name: f.field_name(:title, :subtitle) %>
  #     <%# => <input type="text" name="post[title][subtitle]">
  #   <% end %>
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.field_tag :tag, name: f.field_name(:tag, multiple: true) %>
  #     <%# => <input type="text" name="post[tag][]">
  #   <% end %>
  #
  def field_name: (untyped method, *untyped methods, ?multiple: bool, ?index: untyped) -> untyped
  # Creates a scope around a specific model object like form_for, but
  # doesn't create the form tags themselves. This makes fields_for suitable
  # for specifying additional model objects in the same form.
  #
  # Although the usage and purpose of +fields_for+ is similar to +form_for+'s,
  # its method signature is slightly different. Like +form_for+, it yields
  # a FormBuilder object associated with a particular model object to a block,
  # and within the block allows methods to be called on the builder to
  # generate fields associated with the model object. Fields may reflect
  # a model object in two ways - how they are named (hence how submitted
  # values appear within the +params+ hash in the controller) and what
  # default values are shown when the form the fields appear in is first
  # displayed. In order for both of these features to be specified independently,
  # both an object name (represented by either a symbol or string) and the
  # object itself can be passed to the method separately -
  #
  #   <%= form_for @person do |person_form| %>
  #     First name: <%= person_form.text_field :first_name %>
  #     Last name : <%= person_form.text_field :last_name %>
  #
  #     <%= fields_for :permission, @person.permission do |permission_fields| %>
  #       Admin?  : <%= permission_fields.check_box :admin %>
  #     <% end %>
  #
  #     <%= person_form.submit %>
  #   <% end %>
  #
  # In this case, the checkbox field will be represented by an HTML +input+
  # tag with the +name+ attribute <tt>permission[admin]</tt>, and the submitted
  # value will appear in the controller as <tt>params[:permission][:admin]</tt>.
  # If <tt>@person.permission</tt> is an existing record with an attribute
  # +admin+, the initial state of the checkbox when first displayed will
  # reflect the value of <tt>@person.permission.admin</tt>.
  #
  # Often this can be simplified by passing just the name of the model
  # object to +fields_for+ -
  #
  #   <%= fields_for :permission do |permission_fields| %>
  #     Admin?: <%= permission_fields.check_box :admin %>
  #   <% end %>
  #
  # ...in which case, if <tt>:permission</tt> also happens to be the name of an
  # instance variable <tt>@permission</tt>, the initial state of the input
  # field will reflect the value of that variable's attribute <tt>@permission.admin</tt>.
  #
  # Alternatively, you can pass just the model object itself (if the first
  # argument isn't a string or symbol +fields_for+ will realize that the
  # name has been omitted) -
  #
  #   <%= fields_for @person.permission do |permission_fields| %>
  #     Admin?: <%= permission_fields.check_box :admin %>
  #   <% end %>
  #
  # and +fields_for+ will derive the required name of the field from the
  # _class_ of the model object, e.g. if <tt>@person.permission</tt>, is
  # of class +Permission+, the field will still be named <tt>permission[admin]</tt>.
  #
  # Note: This also works for the methods in FormOptionsHelper and
  # DateHelper that are designed to work with an object as base, like
  # FormOptionsHelper#collection_select and DateHelper#datetime_select.
  #
  # === Nested Attributes Examples
  #
  # When the object belonging to the current scope has a nested attribute
  # writer for a certain attribute, fields_for will yield a new scope
  # for that attribute. This allows you to create forms that set or change
  # the attributes of a parent object and its associations in one go.
  #
  # Nested attribute writers are normal setter methods named after an
  # association. The most common way of defining these writers is either
  # with +accepts_nested_attributes_for+ in a model definition or by
  # defining a method with the proper name. For example: the attribute
  # writer for the association <tt>:address</tt> is called
  # <tt>address_attributes=</tt>.
  #
  # Whether a one-to-one or one-to-many style form builder will be yielded
  # depends on whether the normal reader method returns a _single_ object
  # or an _array_ of objects.
  #
  # ==== One-to-one
  #
  # Consider a Person class which returns a _single_ Address from the
  # <tt>address</tt> reader method and responds to the
  # <tt>address_attributes=</tt> writer method:
  #
  #   class Person
  #     def address
  #       @address
  #     end
  #
  #     def address_attributes=(attributes)
  #       # Process the attributes hash
  #     end
  #   end
  #
  # This model can now be used with a nested fields_for, like so:
  #
  #   <%= form_for @person do |person_form| %>
  #     ...
  #     <%= person_form.fields_for :address do |address_fields| %>
  #       Street  : <%= address_fields.text_field :street %>
  #       Zip code: <%= address_fields.text_field :zip_code %>
  #     <% end %>
  #     ...
  #   <% end %>
  #
  # When address is already an association on a Person you can use
  # +accepts_nested_attributes_for+ to define the writer method for you:
  #
  #   class Person < ActiveRecord::Base
  #     has_one :address
  #     accepts_nested_attributes_for :address
  #   end
  #
  # If you want to destroy the associated model through the form, you have
  # to enable it first using the <tt>:allow_destroy</tt> option for
  # +accepts_nested_attributes_for+:
  #
  #   class Person < ActiveRecord::Base
  #     has_one :address
  #     accepts_nested_attributes_for :address, allow_destroy: true
  #   end
  #
  # Now, when you use a form element with the <tt>_destroy</tt> parameter,
  # with a value that evaluates to +true+, you will destroy the associated
  # model (e.g. 1, '1', true, or 'true'):
  #
  #   <%= form_for @person do |person_form| %>
  #     ...
  #     <%= person_form.fields_for :address do |address_fields| %>
  #       ...
  #       Delete: <%= address_fields.check_box :_destroy %>
  #     <% end %>
  #     ...
  #   <% end %>
  #
  # ==== One-to-many
  #
  # Consider a Person class which returns an _array_ of Project instances
  # from the <tt>projects</tt> reader method and responds to the
  # <tt>projects_attributes=</tt> writer method:
  #
  #   class Person
  #     def projects
  #       [@project1, @project2]
  #     end
  #
  #     def projects_attributes=(attributes)
  #       # Process the attributes hash
  #     end
  #   end
  #
  # Note that the <tt>projects_attributes=</tt> writer method is in fact
  # required for fields_for to correctly identify <tt>:projects</tt> as a
  # collection, and the correct indices to be set in the form markup.
  #
  # When projects is already an association on Person you can use
  # +accepts_nested_attributes_for+ to define the writer method for you:
  #
  #   class Person < ActiveRecord::Base
  #     has_many :projects
  #     accepts_nested_attributes_for :projects
  #   end
  #
  # This model can now be used with a nested fields_for. The block given to
  # the nested fields_for call will be repeated for each instance in the
  # collection:
  #
  #   <%= form_for @person do |person_form| %>
  #     ...
  #     <%= person_form.fields_for :projects do |project_fields| %>
  #       <% if project_fields.object.active? %>
  #         Name: <%= project_fields.text_field :name %>
  #       <% end %>
  #     <% end %>
  #     ...
  #   <% end %>
  #
  # It's also possible to specify the instance to be used:
  #
  #   <%= form_for @person do |person_form| %>
  #     ...
  #     <% @person.projects.each do |project| %>
  #       <% if project.active? %>
  #         <%= person_form.fields_for :projects, project do |project_fields| %>
  #           Name: <%= project_fields.text_field :name %>
  #         <% end %>
  #       <% end %>
  #     <% end %>
  #     ...
  #   <% end %>
  #
  # Or a collection to be used:
  #
  #   <%= form_for @person do |person_form| %>
  #     ...
  #     <%= person_form.fields_for :projects, @active_projects do |project_fields| %>
  #       Name: <%= project_fields.text_field :name %>
  #     <% end %>
  #     ...
  #   <% end %>
  #
  # If you want to destroy any of the associated models through the
  # form, you have to enable it first using the <tt>:allow_destroy</tt>
  # option for +accepts_nested_attributes_for+:
  #
  #   class Person < ActiveRecord::Base
  #     has_many :projects
  #     accepts_nested_attributes_for :projects, allow_destroy: true
  #   end
  #
  # This will allow you to specify which models to destroy in the
  # attributes hash by adding a form element for the <tt>_destroy</tt>
  # parameter with a value that evaluates to +true+
  # (e.g. 1, '1', true, or 'true'):
  #
  #   <%= form_for @person do |person_form| %>
  #     ...
  #     <%= person_form.fields_for :projects do |project_fields| %>
  #       Delete: <%= project_fields.check_box :_destroy %>
  #     <% end %>
  #     ...
  #   <% end %>
  #
  # When a collection is used you might want to know the index of each
  # object into the array. For this purpose, the <tt>index</tt> method
  # is available in the FormBuilder object.
  #
  #   <%= form_for @person do |person_form| %>
  #     ...
  #     <%= person_form.fields_for :projects do |project_fields| %>
  #       Project #<%= project_fields.index %>
  #       ...
  #     <% end %>
  #     ...
  #   <% end %>
  #
  # Note that fields_for will automatically generate a hidden field
  # to store the ID of the record. There are circumstances where this
  # hidden field is not needed and you can pass <tt>include_id: false</tt>
  # to prevent fields_for from rendering it automatically.
  def fields_for: (untyped record_name, ?untyped? record_object, ?::Hash[untyped, untyped] fields_options) ?{ () -> untyped } -> untyped
  # See the docs for the ActionView::Helpers::FormHelper#fields helper method.
  def fields: (?untyped? scope, ?model: untyped?, **untyped options) ?{ () -> untyped } -> untyped
  # Returns a label tag tailored for labelling an input field for a specified attribute (identified by +method+) on an object
  # assigned to the template (identified by +object+). The text of label will default to the attribute name unless a translation
  # is found in the current I18n locale (through <tt>helpers.label.<modelname>.<attribute></tt>) or you specify it explicitly.
  # Additional options on the label tag can be passed as a hash with +options+. These options will be tagged
  # onto the HTML as an HTML element attribute as in the example shown, except for the <tt>:value</tt> option, which is designed to
  # target labels for radio_button tags (where the value is used in the ID of the input tag).
  #
  # ==== Examples
  #   label(:title)
  #   # => <label for="post_title">Title</label>
  #
  # You can localize your labels based on model and attribute names.
  # For example you can define the following in your locale (e.g. en.yml)
  #
  #   helpers:
  #     label:
  #       post:
  #         body: "Write your entire text here"
  #
  # Which then will result in
  #
  #   label(:body)
  #   # => <label for="post_body">Write your entire text here</label>
  #
  # Localization can also be based purely on the translation of the attribute-name
  # (if you are using ActiveRecord):
  #
  #   activerecord:
  #     attributes:
  #       post:
  #         cost: "Total cost"
  #
  #   label(:cost)
  #   # => <label for="post_cost">Total cost</label>
  #
  #   label(:title, "A short title")
  #   # => <label for="post_title">A short title</label>
  #
  #   label(:title, "A short title", class: "title_label")
  #   # => <label for="post_title" class="title_label">A short title</label>
  #
  #   label(:privacy, "Public Post", value: "public")
  #   # => <label for="post_privacy_public">Public Post</label>
  #
  #   label(:cost) do |translation|
  #     content_tag(:span, translation, class: "cost_label")
  #   end
  #   # => <label for="post_cost"><span class="cost_label">Total cost</span></label>
  #
  #   label(:cost) do |builder|
  #     content_tag(:span, builder.translation, class: "cost_label")
  #   end
  #   # => <label for="post_cost"><span class="cost_label">Total cost</span></label>
  #
  #   label(:cost) do |builder|
  #     content_tag(:span, builder.translation, class: [
  #       "cost_label",
  #       ("error_label" if builder.object.errors.include?(:cost))
  #     ])
  #   end
  #   # => <label for="post_cost"><span class="cost_label error_label">Total cost</span></label>
  #
  #   label(:terms) do
  #     raw('Accept <a href="/terms">Terms</a>.')
  #   end
  #   # => <label for="post_terms">Accept <a href="/terms">Terms</a>.</label>
  def label: (untyped method, ?untyped? text, ?::Hash[untyped, untyped] options) ?{ () -> untyped } -> untyped
  # Returns a checkbox tag tailored for accessing a specified attribute (identified by +method+) on an object
  # assigned to the template (identified by +object+). This object must be an instance object (@object) and not a local object.
  # It's intended that +method+ returns an integer and if that integer is above zero, then the checkbox is checked.
  # Additional options on the input tag can be passed as a hash with +options+. The +checked_value+ defaults to 1
  # while the default +unchecked_value+ is set to 0 which is convenient for boolean values.
  #
  # ==== Options
  #
  # * Any standard HTML attributes for the tag can be passed in, for example +:class+.
  # * <tt>:checked</tt> - +true+ or +false+ forces the state of the checkbox to be checked or not.
  # * <tt>:include_hidden</tt> - If set to false, the auxiliary hidden field described below will not be generated.
  #
  # ==== Gotcha
  #
  # The HTML specification says unchecked check boxes are not successful, and
  # thus web browsers do not send them. Unfortunately this introduces a gotcha:
  # if an +Invoice+ model has a +paid+ flag, and in the form that edits a paid
  # invoice the user unchecks its check box, no +paid+ parameter is sent. So,
  # any mass-assignment idiom like
  #
  #   @invoice.update(params[:invoice])
  #
  # wouldn't update the flag.
  #
  # To prevent this the helper generates an auxiliary hidden field before
  # every check box. The hidden field has the same name and its
  # attributes mimic an unchecked check box.
  #
  # This way, the client either sends only the hidden field (representing
  # the check box is unchecked), or both fields. Since the HTML specification
  # says key/value pairs have to be sent in the same order they appear in the
  # form, and parameters extraction gets the last occurrence of any repeated
  # key in the query string, that works for ordinary forms.
  #
  # Unfortunately that workaround does not work when the check box goes
  # within an array-like parameter, as in
  #
  #   <%= fields_for "project[invoice_attributes][]", invoice, index: nil do |form| %>
  #     <%= form.check_box :paid %>
  #     ...
  #   <% end %>
  #
  # because parameter name repetition is precisely what Rails seeks to distinguish
  # the elements of the array. For each item with a checked check box you
  # get an extra ghost item with only that attribute, assigned to "0".
  #
  # In that case it is preferable to either use +check_box_tag+ or to use
  # hashes instead of arrays.
  #
  # ==== Examples
  #
  #   # Let's say that @post.validated? is 1:
  #   check_box("validated")
  #   # => <input name="post[validated]" type="hidden" value="0" />
  #   #    <input checked="checked" type="checkbox" id="post_validated" name="post[validated]" value="1" />
  #
  #   # Let's say that @puppy.gooddog is "no":
  #   check_box("gooddog", {}, "yes", "no")
  #   # => <input name="puppy[gooddog]" type="hidden" value="no" />
  #   #    <input type="checkbox" id="puppy_gooddog" name="puppy[gooddog]" value="yes" />
  #
  #   # Let's say that @eula.accepted is "no":
  #   check_box("accepted", { class: 'eula_check' }, "yes", "no")
  #   # => <input name="eula[accepted]" type="hidden" value="no" />
  #   #    <input type="checkbox" class="eula_check" id="eula_accepted" name="eula[accepted]" value="yes" />
  def check_box: (untyped method, ?::Hash[untyped, untyped] options, ?::String checked_value, ?::String unchecked_value) -> untyped
  # Returns a radio button tag for accessing a specified attribute (identified by +method+) on an object
  # assigned to the template (identified by +object+). If the current value of +method+ is +tag_value+ the
  # radio button will be checked.
  #
  # To force the radio button to be checked pass <tt>checked: true</tt> in the
  # +options+ hash. You may pass HTML options there as well.
  #
  #   # Let's say that @post.category returns "rails":
  #   radio_button("category", "rails")
  #   radio_button("category", "java")
  #   # => <input type="radio" id="post_category_rails" name="post[category]" value="rails" checked="checked" />
  #   #    <input type="radio" id="post_category_java" name="post[category]" value="java" />
  #
  #   # Let's say that @user.receive_newsletter returns "no":
  #   radio_button("receive_newsletter", "yes")
  #   radio_button("receive_newsletter", "no")
  #   # => <input type="radio" id="user_receive_newsletter_yes" name="user[receive_newsletter]" value="yes" />
  #   #    <input type="radio" id="user_receive_newsletter_no" name="user[receive_newsletter]" value="no" checked="checked" />
  def radio_button: (untyped method, untyped tag_value, ?::Hash[untyped, untyped] options) -> untyped
  # Returns a hidden input tag tailored for accessing a specified attribute (identified by +method+) on an object
  # assigned to the template (identified by +object+). Additional options on the input tag can be passed as a
  # hash with +options+. These options will be tagged onto the HTML as an HTML element attribute as in the example
  # shown.
  #
  # ==== Examples
  #   # Let's say that @signup.pass_confirm returns true:
  #   hidden_field(:pass_confirm)
  #   # => <input type="hidden" id="signup_pass_confirm" name="signup[pass_confirm]" value="true" />
  #
  #   # Let's say that @post.tag_list returns "blog, ruby":
  #   hidden_field(:tag_list)
  #   # => <input type="hidden" id="post_tag_list" name="post[tag_list]" value="blog, ruby" />
  #
  #   # Let's say that @user.token returns "abcde":
  #   hidden_field(:token)
  #   # => <input type="hidden" id="user_token" name="user[token]" value="abcde" />
  #
  def hidden_field: (untyped method, ?::Hash[untyped, untyped] options) -> untyped
  # Returns a file upload input tag tailored for accessing a specified attribute (identified by +method+) on an object
  # assigned to the template (identified by +object+). Additional options on the input tag can be passed as a
  # hash with +options+. These options will be tagged onto the HTML as an HTML element attribute as in the example
  # shown.
  #
  # Using this method inside a +form_with+ block will set the enclosing form's encoding to <tt>multipart/form-data</tt>.
  #
  # ==== Options
  # * Creates standard HTML attributes for the tag.
  # * <tt>:disabled</tt> - If set to true, the user will not be able to use this input.
  # * <tt>:multiple</tt> - If set to true, *in most updated browsers* the user will be allowed to select multiple files.
  # * <tt>:include_hidden</tt> - When <tt>multiple: true</tt> and <tt>include_hidden: true</tt>, the field will be prefixed with an <tt><input type="hidden"></tt> field with an empty value to support submitting an empty collection of files.
  # * <tt>:accept</tt> - If set to one or multiple mime-types, the user will be suggested a filter when choosing a file. You still need to set up model validations.
  #
  # ==== Examples
  #   # Let's say that @user has avatar:
  #   file_field(:avatar)
  #   # => <input type="file" id="user_avatar" name="user[avatar]" />
  #
  #   # Let's say that @post has image:
  #   file_field(:image, :multiple => true)
  #   # => <input type="file" id="post_image" name="post[image][]" multiple="multiple" />
  #
  #   # Let's say that @post has attached:
  #   file_field(:attached, accept: 'text/html')
  #   # => <input accept="text/html" type="file" id="post_attached" name="post[attached]" />
  #
  #   # Let's say that @post has image:
  #   file_field(:image, accept: 'image/png,image/gif,image/jpeg')
  #   # => <input type="file" id="post_image" name="post[image]" accept="image/png,image/gif,image/jpeg" />
  #
  #   # Let's say that @attachment has file:
  #   file_field(:file, class: 'file_input')
  #   # => <input type="file" id="attachment_file" name="attachment[file]" class="file_input" />
  def file_field: (untyped method, ?::Hash[untyped, untyped] options) -> untyped
  # Add the submit button for the given form. When no value is given, it checks
  # if the object is a new resource or not to create the proper label:
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # In the example above, if <tt>@post</tt> is a new record, it will use "Create Post" as
  # submit button label; otherwise, it uses "Update Post".
  #
  # Those labels can be customized using I18n under the +helpers.submit+ key and using
  # <tt>%{model}</tt> for translation interpolation:
  #
  #   en:
  #     helpers:
  #       submit:
  #         create: "Create a %{model}"
  #         update: "Confirm changes to %{model}"
  #
  # It also searches for a key specific to the given object:
  #
  #   en:
  #     helpers:
  #       submit:
  #         post:
  #           create: "Add %{model}"
  #
  def submit: (?untyped? value, ?::Hash[untyped, untyped] options) -> untyped
  # Add the submit button for the given form. When no value is given, it checks
  # if the object is a new resource or not to create the proper label:
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.button %>
  #   <% end %>
  #
  # In the example above, if <tt>@post</tt> is a new record, it will use "Create Post" as
  # button label; otherwise, it uses "Update Post".
  #
  # Those labels can be customized using I18n under the +helpers.submit+ key
  # (the same as submit helper) and using <tt>%{model}</tt> for translation interpolation:
  #
  #   en:
  #     helpers:
  #       submit:
  #         create: "Create a %{model}"
  #         update: "Confirm changes to %{model}"
  #
  # It also searches for a key specific to the given object:
  #
  #   en:
  #     helpers:
  #       submit:
  #         post:
  #           create: "Add %{model}"
  #
  # ==== Examples
  #   button("Create post")
  #   # => <button name='button' type='submit'>Create post</button>
  #
  #   button(:draft, value: true)
  #   # => <button id="post_draft" name="post[draft]" value="true" type="submit">Create post</button>
  #
  #   button do
  #     content_tag(:strong, 'Ask me!')
  #   end
  #   # => <button name='button' type='submit'>
  #   #      <strong>Ask me!</strong>
  #   #    </button>
  #
  #   button do |text|
  #     content_tag(:strong, text)
  #   end
  #   # => <button name='button' type='submit'>
  #   #      <strong>Create post</strong>
  #   #    </button>
  #
  #   button(:draft, value: true) do
  #     content_tag(:strong, "Save as draft")
  #   end
  #   # =>  <button id="post_draft" name="post[draft]" value="true" type="submit">
  #   #       <strong>Save as draft</strong>
  #   #     </button>
  #
  def button: (?untyped? value, ?::Hash[untyped, untyped] options) { (untyped) -> untyped } -> untyped
  def emitted_hidden_id?: () -> untyped
  private def objectify_options: (untyped options) -> untyped
  private def submit_default_value: () -> untyped
  private def nested_attributes_association?: (untyped association_name) -> untyped
  private def fields_for_with_nested_attributes: (untyped association_name, untyped association, untyped options, untyped block) -> untyped
  private def fields_for_nested_model: (untyped name, untyped object, untyped fields_options, untyped block) -> untyped
  private def nested_child_index: (untyped name) -> untyped
  private def convert_to_legacy_options: (untyped options) -> (untyped | nil)
  # Wraps ActionView::Helpers::FormOptionsHelper#select for form builders:
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.select :person_id, Person.all.collect { |p| [ p.name, p.id ] }, include_blank: true %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def select: (untyped method, ?untyped? choices, ?::Hash[untyped, untyped] options, ?::Hash[untyped, untyped] html_options) ?{ () -> untyped } -> untyped
  # Wraps ActionView::Helpers::FormOptionsHelper#collection_select for form builders:
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.collection_select :person_id, Author.all, :id, :name_with_initial, prompt: true %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def collection_select: (untyped method, untyped collection, untyped value_method, untyped text_method, ?::Hash[untyped, untyped] options, ?::Hash[untyped, untyped] html_options) -> untyped
  # Wraps ActionView::Helpers::FormOptionsHelper#grouped_collection_select for form builders:
  #
  #   <%= form_for @city do |f| %>
  #     <%= f.grouped_collection_select :country_id, @continents, :countries, :name, :id, :name %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def grouped_collection_select: (untyped method, untyped collection, untyped group_method, untyped group_label_method, untyped option_key_method, untyped option_value_method, ?::Hash[untyped, untyped] options, ?::Hash[untyped, untyped] html_options) -> untyped
  # Wraps ActionView::Helpers::FormOptionsHelper#time_zone_select for form builders:
  #
  #   <%= form_for @user do |f| %>
  #     <%= f.time_zone_select :time_zone, nil, include_blank: true %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def time_zone_select: (untyped method, ?untyped? priority_zones, ?::Hash[untyped, untyped] options, ?::Hash[untyped, untyped] html_options) -> untyped
  # Wraps ActionView::Helpers::FormOptionsHelper#weekday_select for form builders:
  #
  #   <%= form_for @user do |f| %>
  #     <%= f.weekday_select :weekday, include_blank: true %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def weekday_select: (untyped method, ?::Hash[untyped, untyped] options, ?::Hash[untyped, untyped] html_options) -> untyped
  # Wraps ActionView::Helpers::FormOptionsHelper#collection_check_boxes for form builders:
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.collection_check_boxes :author_ids, Author.all, :id, :name_with_initial %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def collection_check_boxes: (untyped method, untyped collection, untyped value_method, untyped text_method, ?::Hash[untyped, untyped] options, ?::Hash[untyped, untyped] html_options) ?{ () -> untyped } -> untyped
  # Wraps ActionView::Helpers::FormOptionsHelper#collection_radio_buttons for form builders:
  #
  #   <%= form_for @post do |f| %>
  #     <%= f.collection_radio_buttons :author_id, Author.all, :id, :name_with_initial %>
  #     <%= f.submit %>
  #   <% end %>
  #
  # Please refer to the documentation of the base helper for details.
  def collection_radio_buttons: (untyped method, untyped collection, untyped value_method, untyped text_method, ?::Hash[untyped, untyped] options, ?::Hash[untyped, untyped] html_options) ?{ () -> untyped } -> untyped
  include ActionView::ModelNaming
  attr_accessor object_name: untyped
  attr_accessor object: untyped
  attr_accessor options: untyped
  attr_reader multipart: untyped
  attr_reader index: untyped
  def self.field_helpers: () -> untyped
  def self.field_helpers?: () -> bool
  def self.field_helpers=: (untyped value) -> untyped
  def field_helpers: () -> untyped
  def field_helpers?: () -> bool
  def field_helpers=: (untyped value) -> untyped
end
