# !!! GENERATED CODE !!!
# Please see generators/rails-generator

module ActionView::Helpers::UrlHelper
  # Basic implementation of url_for to allow use helpers without routes existence
  def url_for: (?untyped? options) -> untyped
  private def _back_url: () -> untyped
  private def _filtered_referrer: () -> untyped
  # Creates an anchor element of the given +name+ using a URL created by the set of +options+.
  # See the valid options in the documentation for +url_for+. It's also possible to
  # pass a \String instead of an options hash, which generates an anchor element that uses the
  # value of the \String as the href for the link. Using a <tt>:back</tt> \Symbol instead
  # of an options hash will generate a link to the referrer (a JavaScript back link
  # will be used in place of a referrer if none exists). If +nil+ is passed as the name
  # the value of the link itself will become the name.
  #
  # ==== Signatures
  #
  #   link_to(body, url, html_options = {})
  #     # url is a String; you can use URL helpers like
  #     # posts_path
  #
  #   link_to(body, url_options = {}, html_options = {})
  #     # url_options, except :method, is passed to url_for
  #
  #   link_to(options = {}, html_options = {}) do
  #     # name
  #   end
  #
  #   link_to(url, html_options = {}) do
  #     # name
  #   end
  #
  #   link_to(active_record_model)
  #
  # ==== Options
  # * <tt>:data</tt> - This option can be used to add custom data attributes.
  #
  # ==== Examples
  #
  # Because it relies on +url_for+, +link_to+ supports both older-style controller/action/id arguments
  # and newer RESTful routes. Current Rails style favors RESTful routes whenever possible, so base
  # your application on resources and use
  #
  #   link_to "Profile", profile_path(@profile)
  #   # => <a href="/profiles/1">Profile</a>
  #
  # or the even pithier
  #
  #   link_to "Profile", @profile
  #   # => <a href="/profiles/1">Profile</a>
  #
  # in place of the older more verbose, non-resource-oriented
  #
  #   link_to "Profile", controller: "profiles", action: "show", id: @profile
  #   # => <a href="/profiles/show/1">Profile</a>
  #
  # Similarly,
  #
  #   link_to "Profiles", profiles_path
  #   # => <a href="/profiles">Profiles</a>
  #
  # is better than
  #
  #   link_to "Profiles", controller: "profiles"
  #   # => <a href="/profiles">Profiles</a>
  #
  # When name is +nil+ the href is presented instead
  #
  #   link_to nil, "http://example.com"
  #   # => <a href="http://www.example.com">http://www.example.com</a>
  #
  # More concise yet, when +name+ is an Active Record model that defines a
  # +to_s+ method returning a default value or a model instance attribute
  #
  #   link_to @profile
  #   # => <a href="http://www.example.com/profiles/1">Eileen</a>
  #
  # You can use a block as well if your link target is hard to fit into the name parameter. ERB example:
  #
  #   <%= link_to(@profile) do %>
  #     <strong><%= @profile.name %></strong> -- <span>Check it out!</span>
  #   <% end %>
  #   # => <a href="/profiles/1">
  #          <strong>David</strong> -- <span>Check it out!</span>
  #        </a>
  #
  # Classes and ids for CSS are easy to produce:
  #
  #   link_to "Articles", articles_path, id: "news", class: "article"
  #   # => <a href="/articles" class="article" id="news">Articles</a>
  #
  # Be careful when using the older argument style, as an extra literal hash is needed:
  #
  #   link_to "Articles", { controller: "articles" }, id: "news", class: "article"
  #   # => <a href="/articles" class="article" id="news">Articles</a>
  #
  # Leaving the hash off gives the wrong link:
  #
  #   link_to "WRONG!", controller: "articles", id: "news", class: "article"
  #   # => <a href="/articles/index/news?class=article">WRONG!</a>
  #
  # +link_to+ can also produce links with anchors or query strings:
  #
  #   link_to "Comment wall", profile_path(@profile, anchor: "wall")
  #   # => <a href="/profiles/1#wall">Comment wall</a>
  #
  #   link_to "Ruby on Rails search", controller: "searches", query: "ruby on rails"
  #   # => <a href="/searches?query=ruby+on+rails">Ruby on Rails search</a>
  #
  #   link_to "Nonsense search", searches_path(foo: "bar", baz: "quux")
  #   # => <a href="/searches?foo=bar&baz=quux">Nonsense search</a>
  #
  # You can set any link attributes such as <tt>target</tt>, <tt>rel</tt>, <tt>type</tt>:
  #
  #   link_to "External link", "http://www.rubyonrails.org/", target: "_blank", rel: "nofollow"
  #   # => <a href="http://www.rubyonrails.org/" target="_blank" rel="nofollow">External link</a>
  #
  # ==== Deprecated: Rails UJS Attributes
  #
  # Prior to Rails 7, Rails shipped with a JavaScript library called <tt>@rails/ujs</tt> on by default. Following Rails 7,
  # this library is no longer on by default. This library integrated with the following options:
  #
  # * <tt>method: symbol of HTTP verb</tt> - This modifier will dynamically
  #   create an HTML form and immediately submit the form for processing using
  #   the HTTP verb specified. Useful for having links perform a POST operation
  #   in dangerous actions like deleting a record (which search bots can follow
  #   while spidering your site). Supported verbs are <tt>:post</tt>, <tt>:delete</tt>, <tt>:patch</tt>, and <tt>:put</tt>.
  #   Note that if the user has JavaScript disabled, the request will fall back
  #   to using GET. If <tt>href: '#'</tt> is used and the user has JavaScript
  #   disabled clicking the link will have no effect. If you are relying on the
  #   POST behavior, you should check for it in your controller's action by using
  #   the request object's methods for <tt>post?</tt>, <tt>delete?</tt>, <tt>patch?</tt>, or <tt>put?</tt>.
  # * <tt>remote: true</tt> - This will allow <tt>@rails/ujs</tt>
  #   to make an Ajax request to the URL in question instead of following
  #   the link.
  #
  # <tt>@rails/ujs</tt> also integrated with the following +:data+ options:
  #
  # * <tt>confirm: "question?"</tt> - This will allow <tt>@rails/ujs</tt>
  #   to prompt with the question specified (in this case, the
  #   resulting text would be <tt>question?</tt>). If the user accepts, the
  #   link is processed normally, otherwise no action is taken.
  # * <tt>:disable_with</tt> - Value of this parameter will be used as the
  #   name for a disabled version of the link.
  #
  # ===== Rails UJS Examples
  #
  #   link_to "Remove Profile", profile_path(@profile), method: :delete
  #   # => <a href="/profiles/1" rel="nofollow" data-method="delete">Remove Profile</a>
  #
  #   link_to "Visit Other Site", "http://www.rubyonrails.org/", data: { confirm: "Are you sure?" }
  #   # => <a href="http://www.rubyonrails.org/" data-confirm="Are you sure?">Visit Other Site</a>
  #
  def link_to: (?untyped? name, ?untyped? options, ?untyped? html_options) ?{ () -> untyped } -> untyped
  # Generates a form containing a single button that submits to the URL created
  # by the set of +options+. This is the safest method to ensure links that
  # cause changes to your data are not triggered by search bots or accelerators.
  # If the HTML button does not work with your layout, you can also consider
  # using the +link_to+ method with the <tt>:method</tt> modifier as described in
  # the +link_to+ documentation.
  #
  # You can control the form and button behavior with +html_options+. Most
  # values in +html_options+ are passed through to the button element. For
  # example, passing a +:class+ option within +html_options+ will set the
  # class attribute of the button element.
  #
  # The class attribute of the form element can be set by passing a
  # +:form_class+ option within +html_options+. It defaults to
  # <tt>"button_to"</tt> to allow styling of the form and its children.
  #
  # The form submits a POST request by default. You can specify a different
  # HTTP verb via the +:method+ option within +html_options+.
  #
  # ==== Options
  # The +options+ hash accepts the same options as +url_for+. To generate a
  # <tt><form></tt> element without an <tt>[action]</tt> attribute, pass
  # <tt>false</tt>:
  #
  #   <%= button_to "New", false %>
  #   # => "<form method="post" class="button_to">
  #   #      <button type="submit">New</button>
  #   #      <input name="authenticity_token" type="hidden" value="10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6"/>
  #   #    </form>"
  #
  # Most values in +html_options+ are passed through to the button element,
  # but there are a few special options:
  #
  # * <tt>:method</tt> - \Symbol of HTTP verb. Supported verbs are <tt>:post</tt>, <tt>:get</tt>,
  #   <tt>:delete</tt>, <tt>:patch</tt>, and <tt>:put</tt>. By default it will be <tt>:post</tt>.
  # * <tt>:disabled</tt> - If set to true, it will generate a disabled button.
  # * <tt>:data</tt> - This option can be used to add custom data attributes.
  # * <tt>:form</tt> - This hash will be form attributes
  # * <tt>:form_class</tt> - This controls the class of the form within which the submit button will
  #   be placed
  # * <tt>:params</tt> - \Hash of parameters to be rendered as hidden fields within the form.
  #
  # ==== Examples
  #   <%= button_to "New", action: "new" %>
  #   # => "<form method="post" action="/controller/new" class="button_to">
  #   #      <button type="submit">New</button>
  #   #      <input name="authenticity_token" type="hidden" value="10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6" autocomplete="off"/>
  #   #    </form>"
  #
  #   <%= button_to "New", new_article_path %>
  #   # => "<form method="post" action="/articles/new" class="button_to">
  #   #      <button type="submit">New</button>
  #   #      <input name="authenticity_token" type="hidden" value="10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6" autocomplete="off"/>
  #   #    </form>"
  #
  #   <%= button_to "New", new_article_path, params: { time: Time.now  } %>
  #   # => "<form method="post" action="/articles/new" class="button_to">
  #   #      <button type="submit">New</button>
  #   #      <input name="authenticity_token" type="hidden" value="10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6"/>
  #   #      <input type="hidden" name="time" value="2021-04-08 14:06:09 -0500" autocomplete="off">
  #   #    </form>"
  #
  #   <%= button_to [:make_happy, @user] do %>
  #     Make happy <strong><%= @user.name %></strong>
  #   <% end %>
  #   # => "<form method="post" action="/users/1/make_happy" class="button_to">
  #   #      <button type="submit">
  #   #        Make happy <strong><%= @user.name %></strong>
  #   #      </button>
  #   #      <input name="authenticity_token" type="hidden" value="10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6"  autocomplete="off"/>
  #   #    </form>"
  #
  #   <%= button_to "New", { action: "new" }, form_class: "new-thing" %>
  #   # => "<form method="post" action="/controller/new" class="new-thing">
  #   #      <button type="submit">New</button>
  #   #      <input name="authenticity_token" type="hidden" value="10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6"  autocomplete="off"/>
  #   #    </form>"
  #
  #   <%= button_to "Create", { action: "create" }, form: { "data-type" => "json" } %>
  #   # => "<form method="post" action="/images/create" class="button_to" data-type="json">
  #   #      <button type="submit">Create</button>
  #   #      <input name="authenticity_token" type="hidden" value="10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6"  autocomplete="off"/>
  #   #    </form>"
  #
  # ==== Deprecated: Rails UJS Attributes
  #
  # Prior to Rails 7, Rails shipped with a JavaScript library called <tt>@rails/ujs</tt> on by default. Following Rails 7,
  # this library is no longer on by default. This library integrated with the following options:
  #
  # * <tt>:remote</tt> -  If set to true, will allow <tt>@rails/ujs</tt> to control the
  #   submit behavior. By default this behavior is an Ajax submit.
  #
  # <tt>@rails/ujs</tt> also integrated with the following +:data+ options:
  #
  # * <tt>confirm: "question?"</tt> - This will allow <tt>@rails/ujs</tt>
  #   to prompt with the question specified (in this case, the
  #   resulting text would be <tt>question?</tt>). If the user accepts, the
  #   button is processed normally, otherwise no action is taken.
  # * <tt>:disable_with</tt> - Value of this parameter will be
  #   used as the value for a disabled version of the submit
  #   button when the form is submitted.
  #
  # ===== Rails UJS Examples
  #
  #   <%= button_to "Create", { action: "create" }, remote: true, form: { "data-type" => "json" } %>
  #   # => "<form method="post" action="/images/create" class="button_to" data-remote="true" data-type="json">
  #   #      <button type="submit">Create</button>
  #   #      <input name="authenticity_token" type="hidden" value="10f2163b45388899ad4d5ae948988266befcb6c3d1b2451cf657a0c293d605a6"  autocomplete="off"/>
  #   #    </form>"
  #
  def button_to: (?untyped? name, ?untyped? options, ?untyped? html_options) ?{ () -> untyped } -> untyped
  # Creates a link tag of the given +name+ using a URL created by the set of
  # +options+ unless the current request URI is the same as the links, in
  # which case only the name is returned (or the given block is yielded, if
  # one exists). You can give +link_to_unless_current+ a block which will
  # specialize the default behavior (e.g., show a "Start Here" link rather
  # than the link's text).
  #
  # ==== Examples
  # Let's say you have a navigation menu...
  #
  #   <ul id="navbar">
  #     <li><%= link_to_unless_current("Home", { action: "index" }) %></li>
  #     <li><%= link_to_unless_current("About Us", { action: "about" }) %></li>
  #   </ul>
  #
  # If in the "about" action, it will render...
  #
  #   <ul id="navbar">
  #     <li><a href="/controller/index">Home</a></li>
  #     <li>About Us</li>
  #   </ul>
  #
  # ...but if in the "index" action, it will render:
  #
  #   <ul id="navbar">
  #     <li>Home</li>
  #     <li><a href="/controller/about">About Us</a></li>
  #   </ul>
  #
  # The implicit block given to +link_to_unless_current+ is evaluated if the current
  # action is the action given. So, if we had a comments page and wanted to render a
  # "Go Back" link instead of a link to the comments page, we could do something like this...
  #
  #    <%=
  #        link_to_unless_current("Comment", { controller: "comments", action: "new" }) do
  #           link_to("Go back", { controller: "posts", action: "index" })
  #        end
  #     %>
  def link_to_unless_current: (untyped name, ?::Hash[untyped, untyped] options, ?::Hash[untyped, untyped] html_options) ?{ () -> untyped } -> untyped
  # Creates a link tag of the given +name+ using a URL created by the set of
  # +options+ unless +condition+ is true, in which case only the name is
  # returned. To specialize the default behavior (i.e., show a login link rather
  # than just the plaintext link text), you can pass a block that
  # accepts the name or the full argument list for +link_to_unless+.
  #
  # ==== Examples
  #   <%= link_to_unless(@current_user.nil?, "Reply", { action: "reply" }) %>
  #   # If the user is logged in...
  #   # => <a href="/controller/reply/">Reply</a>
  #
  #   <%=
  #      link_to_unless(@current_user.nil?, "Reply", { action: "reply" }) do |name|
  #        link_to(name, { controller: "accounts", action: "signup" })
  #      end
  #   %>
  #   # If the user is logged in...
  #   # => <a href="/controller/reply/">Reply</a>
  #   # If not...
  #   # => <a href="/accounts/signup">Reply</a>
  def link_to_unless: (untyped condition, untyped name, ?::Hash[untyped, untyped] options, ?::Hash[untyped, untyped] html_options) ?{ () -> untyped } -> untyped
  # Creates a link tag of the given +name+ using a URL created by the set of
  # +options+ if +condition+ is true, otherwise only the name is
  # returned. To specialize the default behavior, you can pass a block that
  # accepts the name or the full argument list for +link_to_if+.
  #
  # ==== Examples
  #   <%= link_to_if(@current_user.nil?, "Login", { controller: "sessions", action: "new" }) %>
  #   # If the user isn't logged in...
  #   # => <a href="/sessions/new/">Login</a>
  #
  #   <%=
  #      link_to_if(@current_user.nil?, "Login", { controller: "sessions", action: "new" }) do
  #        link_to(@current_user.login, { controller: "accounts", action: "show", id: @current_user })
  #      end
  #   %>
  #   # If the user isn't logged in...
  #   # => <a href="/sessions/new/">Login</a>
  #   # If they are logged in...
  #   # => <a href="/accounts/show/3">my_username</a>
  def link_to_if: (untyped condition, untyped name, ?::Hash[untyped, untyped] options, ?::Hash[untyped, untyped] html_options) ?{ () -> untyped } -> untyped
  # Creates a mailto link tag to the specified +email_address+, which is
  # also used as the name of the link unless +name+ is specified. Additional
  # HTML attributes for the link can be passed in +html_options+.
  #
  # +mail_to+ has several methods for customizing the email itself by
  # passing special keys to +html_options+.
  #
  # ==== Options
  # * <tt>:subject</tt> - Preset the subject line of the email.
  # * <tt>:body</tt> - Preset the body of the email.
  # * <tt>:cc</tt> - Carbon Copy additional recipients on the email.
  # * <tt>:bcc</tt> - Blind Carbon Copy additional recipients on the email.
  # * <tt>:reply_to</tt> - Preset the Reply-To field of the email.
  #
  # ==== Obfuscation
  # Prior to Rails 4.0, +mail_to+ provided options for encoding the address
  # in order to hinder email harvesters.  To take advantage of these options,
  # install the +actionview-encoded_mail_to+ gem.
  #
  # ==== Examples
  #   mail_to "me@domain.com"
  #   # => <a href="mailto:me@domain.com">me@domain.com</a>
  #
  #   mail_to "me@domain.com", "My email"
  #   # => <a href="mailto:me@domain.com">My email</a>
  #
  #   mail_to "me@domain.com", cc: "ccaddress@domain.com",
  #            subject: "This is an example email"
  #   # => <a href="mailto:me@domain.com?cc=ccaddress@domain.com&subject=This%20is%20an%20example%20email">me@domain.com</a>
  #
  # You can use a block as well if your link target is hard to fit into the name parameter. ERB example:
  #
  #   <%= mail_to "me@domain.com" do %>
  #     <strong>Email me:</strong> <span>me@domain.com</span>
  #   <% end %>
  #   # => <a href="mailto:me@domain.com">
  #          <strong>Email me:</strong> <span>me@domain.com</span>
  #        </a>
  def mail_to: (untyped email_address, ?untyped? name, ?::Hash[untyped, untyped] html_options) ?{ () -> untyped } -> untyped
  def current_page?: (*untyped args) -> untyped
  # Creates an SMS anchor link tag to the specified +phone_number+. When the
  # link is clicked, the default SMS messaging app is opened ready to send a
  # message to the linked phone number. If the +body+ option is specified,
  # the contents of the message will be preset to +body+.
  #
  # If +name+ is not specified, +phone_number+ will be used as the name of
  # the link.
  #
  # A +country_code+ option is supported, which prepends a plus sign and the
  # given country code to the linked phone number. For example,
  # <tt>country_code: "01"</tt> will prepend <tt>+01</tt> to the linked
  # phone number.
  #
  # Additional HTML attributes for the link can be passed via +html_options+.
  #
  # ==== Options
  # * <tt>:country_code</tt> - Prepend the country code to the phone number.
  # * <tt>:body</tt> - Preset the body of the message.
  #
  # ==== Examples
  #   sms_to "5155555785"
  #   # => <a href="sms:5155555785;">5155555785</a>
  #
  #   sms_to "5155555785", country_code: "01"
  #   # => <a href="sms:+015155555785;">5155555785</a>
  #
  #   sms_to "5155555785", "Text me"
  #   # => <a href="sms:5155555785;">Text me</a>
  #
  #   sms_to "5155555785", body: "I have a question about your product."
  #   # => <a href="sms:5155555785;?body=I%20have%20a%20question%20about%20your%20product">5155555785</a>
  #
  # You can use a block as well if your link target is hard to fit into the name parameter. \ERB example:
  #
  #   <%= sms_to "5155555785" do %>
  #     <strong>Text me:</strong>
  #   <% end %>
  #   # => <a href="sms:5155555785;">
  #          <strong>Text me:</strong>
  #        </a>
  def sms_to: (untyped phone_number, ?untyped? name, ?::Hash[untyped, untyped] html_options) ?{ () -> untyped } -> untyped
  # Creates a TEL anchor link tag to the specified +phone_number+. When the
  # link is clicked, the default app to make phone calls is opened and
  # prepopulated with the phone number.
  #
  # If +name+ is not specified, +phone_number+ will be used as the name of
  # the link.
  #
  # A +country_code+ option is supported, which prepends a plus sign and the
  # given country code to the linked phone number. For example,
  # <tt>country_code: "01"</tt> will prepend <tt>+01</tt> to the linked
  # phone number.
  #
  # Additional HTML attributes for the link can be passed via +html_options+.
  #
  # ==== Options
  # * <tt>:country_code</tt> - Prepends the country code to the phone number
  #
  # ==== Examples
  #   phone_to "1234567890"
  #   # => <a href="tel:1234567890">1234567890</a>
  #
  #   phone_to "1234567890", "Phone me"
  #   # => <a href="tel:1234567890">Phone me</a>
  #
  #   phone_to "1234567890", country_code: "01"
  #   # => <a href="tel:+011234567890">1234567890</a>
  #
  # You can use a block as well if your link target is hard to fit into the name parameter. \ERB example:
  #
  #   <%= phone_to "1234567890" do %>
  #     <strong>Phone me:</strong>
  #   <% end %>
  #   # => <a href="tel:1234567890">
  #          <strong>Phone me:</strong>
  #        </a>
  def phone_to: (untyped phone_number, ?untyped? name, ?::Hash[untyped, untyped] html_options) ?{ () -> untyped } -> untyped
  private def convert_options_to_data_attributes: (untyped options, untyped html_options) -> (untyped | ::Hash[::String, "true"] | ::Hash[untyped, untyped])
  private def url_target: (untyped name, untyped options) -> untyped
  private def link_to_remote_options?: (untyped options) -> (untyped | nil)
  private def add_method_to_attributes!: (untyped html_options, untyped method) -> untyped
  private def method_for_options: (untyped options) -> (untyped | :patch | :post | untyped | nil)
  private def method_not_get_method?: (untyped method) -> (false | untyped)
  private def token_tag: (?untyped? token, ?form_options: ::Hash[untyped, untyped]) -> (untyped | "")
  private def method_tag: (untyped method) -> untyped
  # Returns an array of hashes each containing :name and :value keys
  # suitable for use as the names and values of form input fields:
  #
  #   to_form_params(name: 'David', nationality: 'Danish')
  #   # => [{name: 'name', value: 'David'}, {name: 'nationality', value: 'Danish'}]
  #
  #   to_form_params(country: { name: 'Denmark' })
  #   # => [{name: 'country[name]', value: 'Denmark'}]
  #
  #   to_form_params(countries: ['Denmark', 'Sweden']})
  #   # => [{name: 'countries[]', value: 'Denmark'}, {name: 'countries[]', value: 'Sweden'}]
  #
  # An optional namespace can be passed to enclose key names:
  #
  #   to_form_params({ name: 'Denmark' }, 'country')
  #   # => [{name: 'country[name]', value: 'Denmark'}]
  private def to_form_params: (untyped attribute, ?untyped? namespace) -> untyped
  private def remove_trailing_slash!: (untyped url_string) -> untyped
  include ActionView::Helpers::TagHelper
  extend ActiveSupport::Concern
  def self.button_to_generates_button_tag: () -> untyped
  def button_to_generates_button_tag: () -> untyped
  def self.button_to_generates_button_tag=: (untyped val) -> untyped
  def button_to_generates_button_tag=: (untyped val) -> untyped
  BUTTON_TAG_METHOD_VERBS: Array[String]
  STRINGIFIED_COMMON_METHODS: Hash[Symbol, String]
end
