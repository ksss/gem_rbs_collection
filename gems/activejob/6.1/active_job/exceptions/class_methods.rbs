# !!! GENERATED CODE !!!
# Please see generators/rails-generator

module ActiveJob::Exceptions::ClassMethods
  # Catch the exception and reschedule job for re-execution after so many seconds, for a specific number of attempts.
  # If the exception keeps getting raised beyond the specified number of attempts, the exception is allowed to
  # bubble up to the underlying queuing system, which may have its own retry mechanism or place it in a
  # holding queue for inspection.
  #
  # You can also pass a block that'll be invoked if the retry attempts fail for custom logic rather than letting
  # the exception bubble up. This block is yielded with the job instance as the first and the error instance as the second parameter.
  #
  # ==== Options
  # * <tt>:wait</tt> - Re-enqueues the job with a delay specified either in seconds (default: 3 seconds),
  #   as a computing proc that takes the number of executions so far as an argument, or as a symbol reference of
  #   <tt>:exponentially_longer</tt>, which applies the wait algorithm of <tt>((executions**4) + (Kernel.rand * (executions**4) * jitter)) + 2</tt>
  #   (first wait ~3s, then ~18s, then ~83s, etc)
  # * <tt>:attempts</tt> - Re-enqueues the job the specified number of times (default: 5 attempts)
  # * <tt>:queue</tt> - Re-enqueues the job on a different queue
  # * <tt>:priority</tt> - Re-enqueues the job with a different priority
  # * <tt>:jitter</tt> - A random delay of wait time used when calculating backoff. The default is 15% (0.15) which represents the upper bound of possible wait time (expressed as a percentage)
  #
  # ==== Examples
  #
  #  class RemoteServiceJob < ActiveJob::Base
  #    retry_on CustomAppException # defaults to ~3s wait, 5 attempts
  #    retry_on AnotherCustomAppException, wait: ->(executions) { executions * 2 }
  #
  #    retry_on ActiveRecord::Deadlocked, wait: 5.seconds, attempts: 3
  #    retry_on Net::OpenTimeout, Timeout::Error, wait: :exponentially_longer, attempts: 10 # retries at most 10 times for Net::OpenTimeout and Timeout::Error combined
  #    # To retry at most 10 times for each individual exception:
  #    # retry_on Net::OpenTimeout, wait: :exponentially_longer, attempts: 10
  #    # retry_on Net::ReadTimeout, wait: 5.seconds, jitter: 0.30, attempts: 10
  #    # retry_on Timeout::Error, wait: :exponentially_longer, attempts: 10
  #
  #    retry_on(YetAnotherCustomAppException) do |job, error|
  #      ExceptionNotifier.caught(error)
  #    end
  #
  #    def perform(*args)
  #      # Might raise CustomAppException, AnotherCustomAppException, or YetAnotherCustomAppException for something domain specific
  #      # Might raise ActiveRecord::Deadlocked when a local db deadlock is detected
  #      # Might raise Net::OpenTimeout or Timeout::Error when the remote service is down
  #    end
  #  end
  def retry_on: (*untyped exceptions, ?wait: untyped, ?attempts: ::Integer, ?queue: untyped?, ?priority: untyped?, ?jitter: untyped) { (untyped, untyped) -> untyped } -> untyped
  # Discard the job with no attempts to retry, if the exception is raised. This is useful when the subject of the job,
  # like an Active Record, is no longer available, and the job is thus no longer relevant.
  #
  # You can also pass a block that'll be invoked. This block is yielded with the job instance as the first and the error instance as the second parameter.
  #
  # ==== Example
  #
  #  class SearchIndexingJob < ActiveJob::Base
  #    discard_on ActiveJob::DeserializationError
  #    discard_on(CustomAppException) do |job, error|
  #      ExceptionNotifier.caught(error)
  #    end
  #
  #    def perform(record)
  #      # Will raise ActiveJob::DeserializationError if the record can't be deserialized
  #      # Might raise CustomAppException for something domain specific
  #    end
  #  end
  def discard_on: (*untyped exceptions) { (untyped, untyped) -> untyped } -> untyped
end
