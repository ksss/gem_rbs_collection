# !!! GENERATED CODE !!!
# Please see generators/rails-generator

module ActiveModel::Validations::HelperMethods
  # Validates whether the value of the specified attribute is available in a
  # particular enumerable object.
  #
  #   class Person < ActiveRecord::Base
  #     validates_inclusion_of :gender, in: %w( m f )
  #     validates_inclusion_of :age, in: 0..99
  #     validates_inclusion_of :format, in: %w( jpg gif png ), message: "extension %{value} is not included in the list"
  #     validates_inclusion_of :states, in: ->(person) { STATES[person.country] }
  #     validates_inclusion_of :karma, in: :available_karmas
  #   end
  #
  # Configuration options:
  # * <tt>:in</tt> - An enumerable object of available items. This can be
  #   supplied as a proc, lambda or symbol which returns an enumerable. If the
  #   enumerable is a numerical, time or datetime range the test is performed
  #   with <tt>Range#cover?</tt>, otherwise with <tt>include?</tt>. When using
  #   a proc or lambda the instance under validation is passed as an argument.
  # * <tt>:within</tt> - A synonym(or alias) for <tt>:in</tt>
  # * <tt>:message</tt> - Specifies a custom error message (default is: "is
  #   not included in the list").
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  def validates_inclusion_of: (*untyped attr_names) -> untyped

  # Validates that the specified attributes are blank (as defined by
  # Object#blank?). Happens by default on save.
  #
  #   class Person < ActiveRecord::Base
  #     validates_absence_of :first_name
  #   end
  #
  # The first_name attribute must be in the object and it must be blank.
  #
  # Configuration options:
  # * <tt>:message</tt> - A custom error message (default is: "must be blank").
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  def validates_absence_of: (*untyped attr_names) -> untyped

  # Validates whether the value of the specified attribute is numeric by
  # trying to convert it to a float with Kernel.Float (if <tt>only_integer</tt>
  # is +false+) or applying it to the regular expression <tt>/\A[\+\-]?\d+\z/</tt>
  # (if <tt>only_integer</tt> is set to +true+).
  #
  #   class Person < ActiveRecord::Base
  #     validates_numericality_of :value, on: :create
  #   end
  #
  # Configuration options:
  # * <tt>:message</tt> - A custom error message (default is: "is not a number").
  # * <tt>:only_integer</tt> - Specifies whether the value has to be an
  #   integer, e.g. an integral value (default is +false+).
  # * <tt>:allow_nil</tt> - Skip validation if attribute is +nil+ (default is
  #   +false+). Notice that for Integer and Float columns empty strings are
  #   converted to +nil+.
  # * <tt>:greater_than</tt> - Specifies the value must be greater than the
  #   supplied value.
  # * <tt>:greater_than_or_equal_to</tt> - Specifies the value must be
  #   greater than or equal the supplied value.
  # * <tt>:equal_to</tt> - Specifies the value must be equal to the supplied
  #   value.
  # * <tt>:less_than</tt> - Specifies the value must be less than the
  #   supplied value.
  # * <tt>:less_than_or_equal_to</tt> - Specifies the value must be less
  #   than or equal the supplied value.
  # * <tt>:other_than</tt> - Specifies the value must be other than the
  #   supplied value.
  # * <tt>:odd</tt> - Specifies the value must be an odd number.
  # * <tt>:even</tt> - Specifies the value must be an even number.
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+ .
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  #
  # The following checks can also be supplied with a proc or a symbol which
  # corresponds to a method:
  #
  # * <tt>:greater_than</tt>
  # * <tt>:greater_than_or_equal_to</tt>
  # * <tt>:equal_to</tt>
  # * <tt>:less_than</tt>
  # * <tt>:less_than_or_equal_to</tt>
  # * <tt>:only_integer</tt>
  #
  # For example:
  #
  #   class Person < ActiveRecord::Base
  #     validates_numericality_of :width, less_than: ->(person) { person.height }
  #     validates_numericality_of :width, greater_than: :minimum_weight
  #   end
  def validates_numericality_of: (*untyped attr_names) -> untyped

  # Validates that the value of the specified attribute is not in a
  # particular enumerable object.
  #
  #   class Person < ActiveRecord::Base
  #     validates_exclusion_of :username, in: %w( admin superuser ), message: "You don't belong here"
  #     validates_exclusion_of :age, in: 30..60, message: 'This site is only for under 30 and over 60'
  #     validates_exclusion_of :format, in: %w( mov avi ), message: "extension %{value} is not allowed"
  #     validates_exclusion_of :password, in: ->(person) { [person.username, person.first_name] },
  #                            message: 'should not be the same as your username or first name'
  #     validates_exclusion_of :karma, in: :reserved_karmas
  #   end
  #
  # Configuration options:
  # * <tt>:in</tt> - An enumerable object of items that the value shouldn't
  #   be part of. This can be supplied as a proc, lambda or symbol which returns an
  #   enumerable. If the enumerable is a numerical, time or datetime range the test
  #   is performed with <tt>Range#cover?</tt>, otherwise with <tt>include?</tt>. When
  #   using a proc or lambda the instance under validation is passed as an argument.
  # * <tt>:within</tt> - A synonym(or alias) for <tt>:in</tt>
  #   <tt>Range#cover?</tt>, otherwise with <tt>include?</tt>.
  # * <tt>:message</tt> - Specifies a custom error message (default is: "is
  #   reserved").
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  def validates_exclusion_of: (*untyped attr_names) -> untyped

  # Encapsulates the pattern of wanting to validate a password or email
  # address field with a confirmation.
  #
  #   Model:
  #     class Person < ActiveRecord::Base
  #       validates_confirmation_of :user_name, :password
  #       validates_confirmation_of :email_address,
  #                                 message: 'should match confirmation'
  #     end
  #
  #   View:
  #     <%= password_field "person", "password" %>
  #     <%= password_field "person", "password_confirmation" %>
  #
  # The added +password_confirmation+ attribute is virtual; it exists only
  # as an in-memory attribute for validating the password. To achieve this,
  # the validation adds accessors to the model for the confirmation
  # attribute.
  #
  # NOTE: This check is performed only if +password_confirmation+ is not
  # +nil+. To require confirmation, make sure to add a presence check for
  # the confirmation attribute:
  #
  #   validates_presence_of :password_confirmation, if: :password_changed?
  #
  # Configuration options:
  # * <tt>:message</tt> - A custom error message (default is: "doesn't match
  #   <tt>%{translated_attribute_name}</tt>").
  # * <tt>:case_sensitive</tt> - Looks for an exact match. Ignored by
  #   non-text columns (+true+ by default).
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  def validates_confirmation_of: (*untyped attr_names) -> untyped

  private def _merge_attributes: (untyped attr_names) -> untyped

  # Validates whether the value of the specified attribute is of the correct
  # form, going by the regular expression provided. You can require that the
  # attribute matches the regular expression:
  #
  #   class Person < ActiveRecord::Base
  #     validates_format_of :email, with: /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i, on: :create
  #   end
  #
  # Alternatively, you can require that the specified attribute does _not_
  # match the regular expression:
  #
  #   class Person < ActiveRecord::Base
  #     validates_format_of :email, without: /NOSPAM/
  #   end
  #
  # You can also provide a proc or lambda which will determine the regular
  # expression that will be used to validate the attribute.
  #
  #   class Person < ActiveRecord::Base
  #     # Admin can have number as a first letter in their screen name
  #     validates_format_of :screen_name,
  #                         with: ->(person) { person.admin? ? /\A[a-z0-9][a-z0-9_\-]*\z/i : /\A[a-z][a-z0-9_\-]*\z/i }
  #   end
  #
  # Note: use <tt>\A</tt> and <tt>\z</tt> to match the start and end of the
  # string, <tt>^</tt> and <tt>$</tt> match the start/end of a line.
  #
  # Due to frequent misuse of <tt>^</tt> and <tt>$</tt>, you need to pass
  # the <tt>multiline: true</tt> option in case you use any of these two
  # anchors in the provided regular expression. In most cases, you should be
  # using <tt>\A</tt> and <tt>\z</tt>.
  #
  # You must pass either <tt>:with</tt> or <tt>:without</tt> as an option.
  # In addition, both must be a regular expression or a proc or lambda, or
  # else an exception will be raised.
  #
  # Configuration options:
  # * <tt>:message</tt> - A custom error message (default is: "is invalid").
  # * <tt>:with</tt> - Regular expression that if the attribute matches will
  #   result in a successful validation. This can be provided as a proc or
  #   lambda returning regular expression which will be called at runtime.
  # * <tt>:without</tt> - Regular expression that if the attribute does not
  #   match will result in a successful validation. This can be provided as
  #   a proc or lambda returning regular expression which will be called at
  #   runtime.
  # * <tt>:multiline</tt> - Set to true if your regular expression contains
  #   anchors that match the beginning or end of lines as opposed to the
  #   beginning or end of the string. These anchors are <tt>^</tt> and <tt>$</tt>.
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  def validates_format_of: (*untyped attr_names) -> untyped

  # Validates that the specified attributes are not blank (as defined by
  # Object#blank?). Happens by default on save.
  #
  #   class Person < ActiveRecord::Base
  #     validates_presence_of :first_name
  #   end
  #
  # The first_name attribute must be in the object and it cannot be blank.
  #
  # If you want to validate the presence of a boolean field (where the real
  # values are +true+ and +false+), you will want to use
  # <tt>validates_inclusion_of :field_name, in: [true, false]</tt>.
  #
  # This is due to the way Object#blank? handles boolean values:
  # <tt>false.blank? # => true</tt>.
  #
  # Configuration options:
  # * <tt>:message</tt> - A custom error message (default is: "can't be blank").
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  def validates_presence_of: (*untyped attr_names) -> untyped

  # Validates that the specified attributes match the length restrictions
  # supplied. Only one constraint option can be used at a time apart from
  # +:minimum+ and +:maximum+ that can be combined together:
  #
  #   class Person < ActiveRecord::Base
  #     validates_length_of :first_name, maximum: 30
  #     validates_length_of :last_name, maximum: 30, message: "less than 30 if you don't mind"
  #     validates_length_of :fax, in: 7..32, allow_nil: true
  #     validates_length_of :phone, in: 7..32, allow_blank: true
  #     validates_length_of :user_name, within: 6..20, too_long: 'pick a shorter name', too_short: 'pick a longer name'
  #     validates_length_of :zip_code, minimum: 5, too_short: 'please enter at least 5 characters'
  #     validates_length_of :smurf_leader, is: 4, message: "papa is spelled with 4 characters... don't play me."
  #     validates_length_of :words_in_essay, minimum: 100, too_short: 'Your essay must be at least 100 words.'
  #
  #     private
  #
  #     def words_in_essay
  #       essay.scan(/\w+/)
  #     end
  #   end
  #
  # Constraint options:
  #
  # * <tt>:minimum</tt> - The minimum size of the attribute.
  # * <tt>:maximum</tt> - The maximum size of the attribute. Allows +nil+ by
  #   default if not used with +:minimum+.
  # * <tt>:is</tt> - The exact size of the attribute.
  # * <tt>:within</tt> - A range specifying the minimum and maximum size of
  #   the attribute.
  # * <tt>:in</tt> - A synonym (or alias) for <tt>:within</tt>.
  #
  # Other options:
  #
  # * <tt>:allow_nil</tt> - Attribute may be +nil+; skip validation.
  # * <tt>:allow_blank</tt> - Attribute may be blank; skip validation.
  # * <tt>:too_long</tt> - The error message if the attribute goes over the
  #   maximum (default is: "is too long (maximum is %{count} characters)").
  # * <tt>:too_short</tt> - The error message if the attribute goes under the
  #   minimum (default is: "is too short (minimum is %{count} characters)").
  # * <tt>:wrong_length</tt> - The error message if using the <tt>:is</tt>
  #   method and the attribute is the wrong size (default is: "is the wrong
  #   length (should be %{count} characters)").
  # * <tt>:message</tt> - The error message to use for a <tt>:minimum</tt>,
  #   <tt>:maximum</tt>, or <tt>:is</tt> violation. An alias of the appropriate
  #   <tt>too_long</tt>/<tt>too_short</tt>/<tt>wrong_length</tt> message.
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+ and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information
  def validates_length_of: (*untyped attr_names) -> untyped

  alias validates_size_of validates_length_of

  # Encapsulates the pattern of wanting to validate the acceptance of a
  # terms of service check box (or similar agreement).
  #
  #   class Person < ActiveRecord::Base
  #     validates_acceptance_of :terms_of_service
  #     validates_acceptance_of :eula, message: 'must be abided'
  #   end
  #
  # If the database column does not exist, the +terms_of_service+ attribute
  # is entirely virtual. This check is performed only if +terms_of_service+
  # is not +nil+ and by default on save.
  #
  # Configuration options:
  # * <tt>:message</tt> - A custom error message (default is: "must be
  #   accepted").
  # * <tt>:accept</tt> - Specifies a value that is considered accepted.
  #   Also accepts an array of possible values. The default value is
  #   an array ["1", true], which makes it easy to relate to an HTML
  #   checkbox. This should be set to, or include, +true+ if you are validating
  #   a database column, since the attribute is typecast from "1" to +true+
  #   before validation.
  #
  # There is also a list of default options supported by every validator:
  # +:if+, +:unless+, +:on+, +:allow_nil+, +:allow_blank+, and +:strict+.
  # See <tt>ActiveModel::Validations#validates</tt> for more information.
  def validates_acceptance_of: (*untyped attr_names) -> untyped
end
