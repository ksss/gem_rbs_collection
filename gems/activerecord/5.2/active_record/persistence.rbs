# !!! GENERATED CODE !!!
# Please see generators/rails-generator

module ActiveRecord::Persistence
  # Returns true if this object hasn't been saved yet -- that is, a record
  # for the object doesn't exist in the database yet; otherwise, returns false.
  def new_record?: () -> untyped

  # Returns true if this object has been destroyed, otherwise returns false.
  def destroyed?: () -> untyped

  # Returns true if the record is persisted, i.e. it's not a new record and it was
  # not destroyed, otherwise returns false.
  def persisted?: () -> untyped

  #
  # :call-seq:
  #   save(*args)
  #
  # Saves the model.
  #
  # If the model is new, a record gets created in the database, otherwise
  # the existing record gets updated.
  #
  # By default, save always runs validations. If any of them fail the action
  # is cancelled and #save returns +false+, and the record won't be saved. However, if you supply
  # <tt>validate: false</tt>, validations are bypassed altogether. See
  # ActiveRecord::Validations for more information.
  #
  # By default, #save also sets the +updated_at+/+updated_on+ attributes to
  # the current time. However, if you supply <tt>touch: false</tt>, these
  # timestamps will not be updated.
  #
  # There's a series of callbacks associated with #save. If any of the
  # <tt>before_*</tt> callbacks throws +:abort+ the action is cancelled and
  # #save returns +false+. See ActiveRecord::Callbacks for further
  # details.
  #
  # Attributes marked as readonly are silently ignored if the record is
  # being updated.
  def save: (*untyped args) ?{ () -> untyped } -> untyped

  #
  # :call-seq:
  #   save!(*args)
  #
  # Saves the model.
  #
  # If the model is new, a record gets created in the database, otherwise
  # the existing record gets updated.
  #
  # By default, #save! always runs validations. If any of them fail
  # ActiveRecord::RecordInvalid gets raised, and the record won't be saved. However, if you supply
  # <tt>validate: false</tt>, validations are bypassed altogether. See
  # ActiveRecord::Validations for more information.
  #
  # By default, #save! also sets the +updated_at+/+updated_on+ attributes to
  # the current time. However, if you supply <tt>touch: false</tt>, these
  # timestamps will not be updated.
  #
  # There's a series of callbacks associated with #save!. If any of
  # the <tt>before_*</tt> callbacks throws +:abort+ the action is cancelled
  # and #save! raises ActiveRecord::RecordNotSaved. See
  # ActiveRecord::Callbacks for further details.
  #
  # Attributes marked as readonly are silently ignored if the record is
  # being updated.
  #
  # Unless an error is raised, returns true.
  def save!: (*untyped args) ?{ () -> untyped } -> untyped

  # Deletes the record in the database and freezes this instance to
  # reflect that no changes should be made (since they can't be
  # persisted). Returns the frozen instance.
  #
  # The row is simply removed with an SQL +DELETE+ statement on the
  # record's primary key, and no callbacks are executed.
  #
  # Note that this will also delete records marked as {#readonly?}[rdoc-ref:Core#readonly?].
  #
  # To enforce the object's +before_destroy+ and +after_destroy+
  # callbacks or any <tt>:dependent</tt> association
  # options, use <tt>#destroy</tt>.
  def delete: () -> untyped

  # Deletes the record in the database and freezes this instance to reflect
  # that no changes should be made (since they can't be persisted).
  #
  # There's a series of callbacks associated with #destroy. If the
  # <tt>before_destroy</tt> callback throws +:abort+ the action is cancelled
  # and #destroy returns +false+.
  # See ActiveRecord::Callbacks for further details.
  def destroy: () -> untyped

  # Deletes the record in the database and freezes this instance to reflect
  # that no changes should be made (since they can't be persisted).
  #
  # There's a series of callbacks associated with #destroy!. If the
  # <tt>before_destroy</tt> callback throws +:abort+ the action is cancelled
  # and #destroy! raises ActiveRecord::RecordNotDestroyed.
  # See ActiveRecord::Callbacks for further details.
  def destroy!: () -> untyped

  # Returns an instance of the specified +klass+ with the attributes of the
  # current record. This is mostly useful in relation to single-table
  # inheritance structures where you want a subclass to appear as the
  # superclass. This can be used along with record identification in
  # Action Pack to allow, say, <tt>Client < Company</tt> to do something
  # like render <tt>partial: @client.becomes(Company)</tt> to render that
  # instance using the companies/company partial instead of clients/client.
  #
  # Note: The new instance will share a link to the same attributes as the original class.
  # Therefore the sti column value will still be the same.
  # Any change to the attributes on either instance will affect both instances.
  # If you want to change the sti column as well, use #becomes! instead.
  def becomes: (untyped klass) -> untyped

  # Wrapper around #becomes that also changes the instance's sti column value.
  # This is especially useful if you want to persist the changed class in your
  # database.
  #
  # Note: The old instance's sti column value will be changed too, as both objects
  # share the same set of attributes.
  def becomes!: (untyped klass) -> untyped

  # Updates a single attribute and saves the record.
  # This is especially useful for boolean flags on existing records. Also note that
  #
  # * Validation is skipped.
  # * \Callbacks are invoked.
  # * updated_at/updated_on column is updated if that column is available.
  # * Updates all the attributes that are dirty in this object.
  #
  # This method raises an ActiveRecord::ActiveRecordError  if the
  # attribute is marked as readonly.
  #
  # Also see #update_column.
  def update_attribute: (untyped name, untyped value) -> untyped

  # Updates the attributes of the model from the passed-in hash and saves the
  # record, all wrapped in a transaction. If the object is invalid, the saving
  # will fail and false will be returned.
  def update: (untyped attributes) -> untyped

  alias update_attributes update

  # Updates its receiver just like #update but calls #save! instead
  # of +save+, so an exception is raised if the record is invalid and saving will fail.
  def update!: (untyped attributes) -> untyped

  alias update_attributes! update!

  # Equivalent to <code>update_columns(name => value)</code>.
  def update_column: (untyped name, untyped value) -> untyped

  # Updates the attributes directly in the database issuing an UPDATE SQL
  # statement and sets them in the receiver:
  #
  #   user.update_columns(last_request_at: Time.current)
  #
  # This is the fastest way to update attributes because it goes straight to
  # the database, but take into account that in consequence the regular update
  # procedures are totally bypassed. In particular:
  #
  # * \Validations are skipped.
  # * \Callbacks are skipped.
  # * +updated_at+/+updated_on+ are not updated.
  # * However, attributes are serialized with the same rules as ActiveRecord::Relation#update_all
  #
  # This method raises an ActiveRecord::ActiveRecordError when called on new
  # objects, or when at least one of the attributes is marked as readonly.
  def update_columns: (untyped attributes) -> untyped

  # Initializes +attribute+ to zero if +nil+ and adds the value passed as +by+ (default is 1).
  # The increment is performed directly on the underlying attribute, no setter is invoked.
  # Only makes sense for number-based attributes. Returns +self+.
  def increment: (untyped attribute, ?::Integer by) -> self

  # Wrapper around #increment that writes the update to the database.
  # Only +attribute+ is updated; the record itself is not saved.
  # This means that any other modified attributes will still be dirty.
  # Validations and callbacks are skipped. Supports the +touch+ option from
  # +update_counters+, see that for more.
  # Returns +self+.
  def increment!: (untyped attribute, ?::Integer by, ?touch: untyped?) -> self

  # Initializes +attribute+ to zero if +nil+ and subtracts the value passed as +by+ (default is 1).
  # The decrement is performed directly on the underlying attribute, no setter is invoked.
  # Only makes sense for number-based attributes. Returns +self+.
  def decrement: (untyped attribute, ?::Integer by) -> untyped

  # Wrapper around #decrement that writes the update to the database.
  # Only +attribute+ is updated; the record itself is not saved.
  # This means that any other modified attributes will still be dirty.
  # Validations and callbacks are skipped. Supports the +touch+ option from
  # +update_counters+, see that for more.
  # Returns +self+.
  def decrement!: (untyped attribute, ?::Integer by, ?touch: untyped?) -> untyped

  # Assigns to +attribute+ the boolean opposite of <tt>attribute?</tt>. So
  # if the predicate returns +true+ the attribute will become +false+. This
  # method toggles directly the underlying value without calling any setter.
  # Returns +self+.
  #
  # Example:
  #
  #   user = User.first
  #   user.banned? # => false
  #   user.toggle(:banned)
  #   user.banned? # => true
  #
  def toggle: (untyped attribute) -> self

  # Wrapper around #toggle that saves the record. This method differs from
  # its non-bang version in the sense that it passes through the attribute setter.
  # Saving is not subjected to validation checks. Returns +true+ if the
  # record could be saved.
  def toggle!: (untyped attribute) -> untyped

  # Reloads the record from the database.
  #
  # This method finds the record by its primary key (which could be assigned
  # manually) and modifies the receiver in-place:
  #
  #   account = Account.new
  #   # => #<Account id: nil, email: nil>
  #   account.id = 1
  #   account.reload
  #   # Account Load (1.2ms)  SELECT "accounts".* FROM "accounts" WHERE "accounts"."id" = $1 LIMIT 1  [["id", 1]]
  #   # => #<Account id: 1, email: 'account@example.com'>
  #
  # Attributes are reloaded from the database, and caches busted, in
  # particular the associations cache and the QueryCache.
  #
  # If the record no longer exists in the database ActiveRecord::RecordNotFound
  # is raised. Otherwise, in addition to the in-place modification the method
  # returns +self+ for convenience.
  #
  # The optional <tt>:lock</tt> flag option allows you to lock the reloaded record:
  #
  #   reload(lock: true) # reload with pessimistic locking
  #
  # Reloading is commonly used in test suites to test something is actually
  # written to the database, or when some action modifies the corresponding
  # row in the database but not the object in memory:
  #
  #   assert account.deposit!(25)
  #   assert_equal 25, account.credit        # check it is updated in memory
  #   assert_equal 25, account.reload.credit # check it is also persisted
  #
  # Another common use case is optimistic locking handling:
  #
  #   def with_optimistic_retry
  #     begin
  #       yield
  #     rescue ActiveRecord::StaleObjectError
  #       begin
  #         # Reload lock_version in particular.
  #         reload
  #       rescue ActiveRecord::RecordNotFound
  #         # If the record is gone there is nothing to do.
  #       else
  #         retry
  #       end
  #     end
  #   end
  #
  def reload: (?untyped? options) -> self

  # Saves the record with the updated_at/on attributes set to the current time
  # or the time specified.
  # Please note that no validation is performed and only the +after_touch+,
  # +after_commit+ and +after_rollback+ callbacks are executed.
  #
  # This method can be passed attribute names and an optional time argument.
  # If attribute names are passed, they are updated along with updated_at/on
  # attributes. If no time argument is passed, the current time is used as default.
  #
  #   product.touch                         # updates updated_at/on with current time
  #   product.touch(time: Time.new(2015, 2, 16, 0, 0, 0)) # updates updated_at/on with specified time
  #   product.touch(:designed_at)           # updates the designed_at attribute and updated_at/on
  #   product.touch(:started_at, :ended_at) # updates started_at, ended_at and updated_at/on attributes
  #
  # If used along with {belongs_to}[rdoc-ref:Associations::ClassMethods#belongs_to]
  # then +touch+ will invoke +touch+ method on associated object.
  #
  #   class Brake < ActiveRecord::Base
  #     belongs_to :car, touch: true
  #   end
  #
  #   class Car < ActiveRecord::Base
  #     belongs_to :corporation, touch: true
  #   end
  #
  #   # triggers @brake.car.touch and @brake.car.corporation.touch
  #   @brake.touch
  #
  # Note that +touch+ must be used on a persisted object, or else an
  # ActiveRecordError will be thrown. For example:
  #
  #   ball = Ball.new
  #   ball.touch(:updated_at)   # => raises ActiveRecordError
  #
  def touch: (*untyped names, ?time: untyped?) -> untyped

  # A hook to be overridden by association modules.
  private def destroy_associations: () -> nil

  private def destroy_row: () -> untyped

  private def _delete_row: () -> untyped

  private def _touch_row: (untyped attribute_names, untyped time) -> untyped

  private def _update_row: (untyped attribute_names, ?::String attempted_action) -> untyped

  private def create_or_update: (*untyped args) ?{ () -> untyped } -> (false | untyped)

  # Updates the associated record with values matching those of the instance attributes.
  # Returns the number of affected rows.
  private def _update_record: (?untyped attribute_names) { (untyped) -> untyped } -> untyped

  # Creates a record with values matching those of the instance attributes
  # and returns its id.
  private def _create_record: (?untyped attribute_names) { (untyped) -> untyped } -> untyped

  private def verify_readonly_attribute: (untyped name) -> (untyped | nil)

  private def _raise_record_not_destroyed: () -> untyped

  private def belongs_to_touch_method: () -> :touch

  private def _raise_readonly_record_error: () -> untyped

  extend ActiveSupport::Concern
end
