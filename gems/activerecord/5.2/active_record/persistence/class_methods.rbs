# !!! GENERATED CODE !!!
# Please see generators/rails-generator

module ActiveRecord::Persistence::ClassMethods
  # Creates an object (or multiple objects) and saves it to the database, if validations pass.
  # The resulting object is returned whether the object was saved successfully to the database or not.
  #
  # The +attributes+ parameter can be either a Hash or an Array of Hashes. These Hashes describe the
  # attributes on the objects that are to be created.
  #
  # ==== Examples
  #   # Create a single new object
  #   User.create(first_name: 'Jamie')
  #
  #   # Create an Array of new objects
  #   User.create([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }])
  #
  #   # Create a single object and pass it into a block to set other attributes.
  #   User.create(first_name: 'Jamie') do |u|
  #     u.is_admin = false
  #   end
  #
  #   # Creating an Array of new objects using a block, where the block is executed for each object:
  #   User.create([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }]) do |u|
  #     u.is_admin = false
  #   end
  def create: (?untyped? attributes) ?{ () -> untyped } -> untyped

  # Creates an object (or multiple objects) and saves it to the database,
  # if validations pass. Raises a RecordInvalid error if validations fail,
  # unlike Base#create.
  #
  # The +attributes+ parameter can be either a Hash or an Array of Hashes.
  # These describe which attributes to be created on the object, or
  # multiple objects when given an Array of Hashes.
  def create!: (?untyped? attributes) ?{ () -> untyped } -> untyped

  # Given an attributes hash, +instantiate+ returns a new instance of
  # the appropriate class. Accepts only keys as strings.
  #
  # For example, +Post.all+ may return Comments, Messages, and Emails
  # by storing the record's subclass in a +type+ attribute. By calling
  # +instantiate+ instead of +new+, finder methods ensure they get new
  # instances of the appropriate class for each record.
  #
  # See <tt>ActiveRecord::Inheritance#discriminate_class_for_record</tt> to see
  # how this "single-table" inheritance mapping is implemented.
  def instantiate: (untyped attributes, ?::Hash[untyped, untyped] column_types) ?{ () -> untyped } -> untyped

  # Updates an object (or multiple objects) and saves it to the database, if validations pass.
  # The resulting object is returned whether the object was saved successfully to the database or not.
  #
  # ==== Parameters
  #
  # * +id+ - This should be the id or an array of ids to be updated.
  # * +attributes+ - This should be a hash of attributes or an array of hashes.
  #
  # ==== Examples
  #
  #   # Updates one record
  #   Person.update(15, user_name: "Samuel", group: "expert")
  #
  #   # Updates multiple records
  #   people = { 1 => { "first_name" => "David" }, 2 => { "first_name" => "Jeremy" } }
  #   Person.update(people.keys, people.values)
  #
  #   # Updates multiple records from the result of a relation
  #   people = Person.where(group: "expert")
  #   people.update(group: "masters")
  #
  # Note: Updating a large number of records will run an UPDATE
  # query for each record, which may cause a performance issue.
  # When running callbacks is not needed for each record update,
  # it is preferred to use {update_all}[rdoc-ref:Relation#update_all]
  # for updating all records in a single query.
  def update: (?::Symbol id, untyped attributes) -> untyped

  # Destroy an object (or multiple objects) that has the given id. The object is instantiated first,
  # therefore all callbacks and filters are fired off before the object is deleted. This method is
  # less efficient than #delete but allows cleanup methods and other actions to be run.
  #
  # This essentially finds the object (or multiple objects) with the given id, creates a new object
  # from the attributes, and then calls destroy on it.
  #
  # ==== Parameters
  #
  # * +id+ - This should be the id or an array of ids to be destroyed.
  #
  # ==== Examples
  #
  #   # Destroy a single object
  #   Todo.destroy(1)
  #
  #   # Destroy multiple objects
  #   todos = [1,2,3]
  #   Todo.destroy(todos)
  def destroy: (untyped id) -> untyped

  # Deletes the row with a primary key matching the +id+ argument, using a
  # SQL +DELETE+ statement, and returns the number of rows deleted. Active
  # Record objects are not instantiated, so the object's callbacks are not
  # executed, including any <tt>:dependent</tt> association options.
  #
  # You can delete multiple rows at once by passing an Array of <tt>id</tt>s.
  #
  # Note: Although it is often much faster than the alternative, #destroy,
  # skipping callbacks might bypass business logic in your application
  # that ensures referential integrity or performs other essential jobs.
  #
  # ==== Examples
  #
  #   # Delete a single row
  #   Todo.delete(1)
  #
  #   # Delete multiple rows
  #   Todo.delete([2,3,4])
  def delete: (untyped id_or_array) -> untyped

  def _insert_record: (untyped values) -> untyped

  def _update_record: (untyped values, untyped constraints) -> untyped

  def _delete_record: (untyped constraints) -> untyped

  # Called by +instantiate+ to decide which class to use for a new
  # record instance.
  #
  # See +ActiveRecord::Inheritance#discriminate_class_for_record+ for
  # the single-table inheritance discriminator.
  private def discriminate_class_for_record: (untyped record) -> self

  private def _substitute_values: (untyped values) -> untyped
end
