# !!! GENERATED CODE !!!
# Please see generators/rails-generator

module ActiveRecord::ConnectionHandling
  # Establishes a connection to the database that's used by all Active Record objects.
  def mysql2_connection: (untyped config) -> untyped
  # Establishes a connection to the database that's used by all Active Record objects
  def postgresql_connection: (untyped config) -> untyped
  def sqlite3_connection: (untyped config) -> untyped
  # Establishes the connection to the database. Accepts a hash as input where
  # the <tt>:adapter</tt> key must be specified with the name of a database adapter (in lower-case)
  # example for regular databases (MySQL, PostgreSQL, etc):
  #
  #   ActiveRecord::Base.establish_connection(
  #     adapter:  "mysql2",
  #     host:     "localhost",
  #     username: "myuser",
  #     password: "mypass",
  #     database: "somedatabase"
  #   )
  #
  # Example for SQLite database:
  #
  #   ActiveRecord::Base.establish_connection(
  #     adapter:  "sqlite3",
  #     database: "path/to/dbfile"
  #   )
  #
  # Also accepts keys as strings (for parsing from YAML for example):
  #
  #   ActiveRecord::Base.establish_connection(
  #     "adapter"  => "sqlite3",
  #     "database" => "path/to/dbfile"
  #   )
  #
  # Or a URL:
  #
  #   ActiveRecord::Base.establish_connection(
  #     "postgres://myuser:mypass@localhost/somedatabase"
  #   )
  #
  # In case {ActiveRecord::Base.configurations}[rdoc-ref:Core.configurations]
  # is set (Rails automatically loads the contents of config/database.yml into it),
  # a symbol can also be given as argument, representing a key in the
  # configuration hash:
  #
  #   ActiveRecord::Base.establish_connection(:production)
  #
  # The exceptions AdapterNotSpecified, AdapterNotFound and +ArgumentError+
  # may be returned on an error.
  def establish_connection: (?untyped? config_or_env) -> untyped
  # Connects a model to the databases specified. The +database+ keyword
  # takes a hash consisting of a +role+ and a +database_key+.
  #
  # This will create a connection handler for switching between connections,
  # look up the config hash using the +database_key+ and finally
  # establishes a connection to that config.
  #
  #   class AnimalsModel < ApplicationRecord
  #     self.abstract_class = true
  #
  #     connects_to database: { writing: :primary, reading: :primary_replica }
  #   end
  #
  # Returns an array of established connections.
  def connects_to: (?database: ::Hash[untyped, untyped]) -> untyped
  # Connects to a database or role (ex writing, reading, or another
  # custom role) for the duration of the block.
  #
  # If a role is passed, Active Record will look up the connection
  # based on the requested role:
  #
  #   ActiveRecord::Base.connected_to(role: :writing) do
  #     Dog.create! # creates dog using dog writing connection
  #   end
  #
  #   ActiveRecord::Base.connected_to(role: :reading) do
  #     Dog.create! # throws exception because we're on a replica
  #   end
  #
  #   ActiveRecord::Base.connected_to(role: :unknown_role) do
  #     # raises exception due to non-existent role
  #   end
  #
  # The `database` kwarg is deprecated in 6.1 and will be removed in 6.2
  #
  # It is not recommended for use as it re-establishes a connection every
  # time it is called.
  def connected_to: (?database: untyped?, ?role: untyped?, ?prevent_writes: bool) ?{ () -> untyped } -> untyped
  # Returns true if role is the current connected role.
  #
  #   ActiveRecord::Base.connected_to(role: :writing) do
  #     ActiveRecord::Base.connected_to?(role: :writing) #=> true
  #     ActiveRecord::Base.connected_to?(role: :reading) #=> false
  #   end
  def connected_to?: (role: untyped) -> untyped
  # Returns the symbol representing the current connected role.
  #
  #   ActiveRecord::Base.connected_to(role: :writing) do
  #     ActiveRecord::Base.current_role #=> :writing
  #   end
  #
  #   ActiveRecord::Base.connected_to(role: :reading) do
  #     ActiveRecord::Base.current_role #=> :reading
  #   end
  def current_role: () -> untyped
  def lookup_connection_handler: (untyped handler_key) -> untyped
  def with_handler: (untyped handler_key) ?{ () -> untyped } -> untyped
  def resolve_config_for_connection: (untyped config_or_env) -> untyped
  # Clears the query cache for all connections associated with the current thread.
  def clear_query_caches_for_current_thread: () -> untyped
  # Returns the connection currently associated with the class. This can
  # also be used to "borrow" the connection to do database work unrelated
  # to any of the specific Active Records.
  def connection: () -> untyped
  # Return the specification name from the current class or its parent.
  def connection_specification_name: () -> untyped
  def primary_class?: () -> untyped
  # Returns the configuration of the associated connection as a hash:
  #
  #  ActiveRecord::Base.connection_config
  #  # => {pool: 5, timeout: 5000, database: "db/development.sqlite3", adapter: "sqlite3"}
  #
  # Please use only for reading.
  def connection_config: () -> untyped
  def connection_pool: () -> untyped
  def retrieve_connection: () -> untyped
  # Returns +true+ if Active Record is connected.
  def connected?: () -> untyped
  def remove_connection: (?untyped? name) -> untyped
  def clear_cache!: () -> untyped
  private def swap_connection_handler: (untyped handler) { () -> untyped } -> untyped
  attr_writer connection_specification_name: untyped
  # defined by `delegate` to: #connection_handler
  def clear_active_connections!: (*untyped, **untyped) -> untyped
  # defined by `delegate` to: #connection_handler
  def clear_reloadable_connections!: (*untyped, **untyped) -> untyped
  # defined by `delegate` to: #connection_handler
  def clear_all_connections!: (*untyped, **untyped) -> untyped
  # defined by `delegate` to: #connection_handler
  def flush_idle_connections!: (*untyped, **untyped) -> untyped
  DEFAULT_ENV: Proc
  RAILS_ENV: Proc
end
