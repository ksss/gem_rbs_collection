# !!! GENERATED CODE !!!
# Please see generators/rails-generator

class ActiveRecord::Associations::Association
  def initialize: (untyped owner, untyped reflection) -> void
  # Resets the \loaded flag to +false+ and sets the \target to +nil+.
  def reset: () -> untyped
  def reset_negative_cache: () -> (untyped | nil)
  # Reloads the \target and returns +self+ on success.
  # The QueryCache is cleared if +force+ is true.
  def reload: (?bool force) -> untyped
  # Has the \target been already \loaded?
  def loaded?: () -> untyped
  # Asserts the \target has been loaded setting the \loaded flag to +true+.
  def loaded!: () -> untyped
  # The target is stale if the target no longer points to the record(s) that the
  # relevant foreign_key(s) refers to. If stale, the association accessor method
  # on the owner will reload the target. It's up to subclasses to implement the
  # stale_state method if relevant.
  #
  # Note that if the target has not been loaded, it is not considered stale.
  def stale_target?: () -> untyped
  # Sets the target of this association to <tt>\target</tt>, and the \loaded flag to +true+.
  def target=: (untyped target) -> untyped
  def scope: () -> untyped
  def reset_scope: () -> untyped
  # Set the inverse association, if possible
  def set_inverse_instance: (untyped record) -> untyped
  def set_inverse_instance_from_queries: (untyped record) -> untyped
  # Remove the inverse association, if possible
  def remove_inverse_instance: (untyped record) -> (untyped | nil)
  def inversed_from: (untyped record) -> untyped
  def inversed_from_queries: (untyped record) -> untyped
  # Returns the class of the target. belongs_to polymorphic overrides this to look at the
  # polymorphic_type field on the owner.
  def klass: () -> untyped
  def extensions: () -> untyped
  # Loads the \target if needed and returns it.
  #
  # This method is abstract in the sense that it relies on +find_target+,
  # which is expected to be provided by descendants.
  #
  # If the \target is already \loaded it is just returned. Thus, you can call
  # +load_target+ unconditionally to get the \target.
  #
  # ActiveRecord::RecordNotFound is rescued within the method, and it is
  # not reraised. The proxy is \reset and +nil+ is the return value.
  def load_target: () -> untyped
  # We can't dump @reflection and @through_reflection since it contains the scope proc
  def marshal_dump: () -> ::Array[untyped]
  def marshal_load: (untyped data) -> untyped
  def initialize_attributes: (untyped record, ?untyped? except_from_scope_attributes) -> untyped
  def create: (?untyped? attributes) ?{ () -> untyped } -> untyped
  def create!: (?untyped? attributes) ?{ () -> untyped } -> untyped
  private def find_target: () -> untyped
  private def strict_loading?: () -> untyped
  # The scope for this association.
  #
  # Note that the association_scope is merged into the target_scope only when the
  # scope method is called. This is because at that point the call may be surrounded
  # by scope.scoping { ... } or unscoped { ... } etc, which affects the scope which
  # actually gets built.
  private def association_scope: () -> (untyped | nil)
  # Can be overridden (i.e. in ThroughAssociation) to merge in other scopes (i.e. the
  # through association's scope)
  private def target_scope: () -> untyped
  private def scope_for_create: () -> untyped
  private def find_target?: () -> untyped
  # Returns true if there is a foreign key present on the owner which
  # references the target. This is used to determine whether we can load
  # the target if the owner is currently a new record (and therefore
  # without a key). If the owner is a new record then foreign_key must
  # be present in order to load target.
  #
  # Currently implemented by belongs_to (vanilla and polymorphic) and
  # has_one/has_many :through associations which go through a belongs_to.
  private def foreign_key_present?: () -> false
  # Raises ActiveRecord::AssociationTypeMismatch unless +record+ is of
  # the kind of the class of the associated objects. Meant to be used as
  # a sanity check when you are about to assign an associated record.
  private def raise_on_type_mismatch!: (untyped record) -> (untyped | nil)
  private def inverse_association_for: (untyped record) -> (untyped | nil)
  # Can be redefined by subclasses, notably polymorphic belongs_to
  # The record parameter is necessary to support polymorphic inverses as we must check for
  # the association in the specific class of the record.
  private def inverse_reflection_for: (untyped record) -> untyped
  # Returns true if inverse association on the given record needs to be set.
  # This method is redefined by subclasses.
  private def invertible_for?: (untyped record) -> untyped
  # Returns true if record contains the foreign_key
  private def foreign_key_for?: (untyped record) -> untyped
  # This should be implemented to return the values of the relevant key(s) on the owner,
  # so that when stale_state is different from the value stored on the last find_target,
  # the target is stale.
  #
  # This is only relevant to certain associations, which is why it returns +nil+ by default.
  private def stale_state: () -> nil
  private def build_record: (untyped attributes) { (untyped) -> untyped } -> untyped
  # Returns true if statement cache should be skipped on the association reader.
  private def skip_statement_cache?: (untyped scope) -> untyped
  private def enqueue_destroy_association: (untyped options) -> untyped
  private def inversable?: (untyped record) -> untyped
  private def matches_foreign_key?: (untyped record) -> untyped
  attr_reader owner: untyped
  attr_reader target: untyped
  attr_reader reflection: untyped
  # defined by `delegate` to: untyped#reflection
  def options: (*untyped, **untyped) -> untyped
end
