# !!! GENERATED CODE !!!
# Please see generators/rails-generator

module ActiveRecord::FinderMethods
  # Find by id - This can either be a specific id (1), a list of ids (1, 5, 6), or an array of ids ([5, 6, 10]).
  # If one or more records cannot be found for the requested ids, then ActiveRecord::RecordNotFound will be raised.
  # If the primary key is an integer, find by id coerces its arguments by using +to_i+.
  #
  #   Person.find(1)          # returns the object for ID = 1
  #   Person.find("1")        # returns the object for ID = 1
  #   Person.find("31-sarah") # returns the object for ID = 31
  #   Person.find(1, 2, 6)    # returns an array for objects with IDs in (1, 2, 6)
  #   Person.find([7, 17])    # returns an array for objects with IDs in (7, 17)
  #   Person.find([1])        # returns an array for the object with ID = 1
  #   Person.where("administrator = 1").order("created_on DESC").find(1)
  #
  # NOTE: The returned records are in the same order as the ids you provide.
  # If you want the results to be sorted by database, you can use ActiveRecord::QueryMethods#where
  # method and provide an explicit ActiveRecord::QueryMethods#order option.
  # But ActiveRecord::QueryMethods#where method doesn't raise ActiveRecord::RecordNotFound.
  #
  # ==== Find with lock
  #
  # Example for find with a lock: Imagine two concurrent transactions:
  # each will read <tt>person.visits == 2</tt>, add 1 to it, and save, resulting
  # in two saves of <tt>person.visits = 3</tt>. By locking the row, the second
  # transaction has to wait until the first is finished; we get the
  # expected <tt>person.visits == 4</tt>.
  #
  #   Person.transaction do
  #     person = Person.lock(true).find(1)
  #     person.visits += 1
  #     person.save!
  #   end
  #
  # ==== Variations of #find
  #
  #   Person.where(name: 'Spartacus', rating: 4)
  #   # returns a chainable list (which can be empty).
  #
  #   Person.find_by(name: 'Spartacus', rating: 4)
  #   # returns the first item or nil.
  #
  #   Person.find_or_initialize_by(name: 'Spartacus', rating: 4)
  #   # returns the first item or returns a new instance (requires you call .save to persist against the database).
  #
  #   Person.find_or_create_by(name: 'Spartacus', rating: 4)
  #   # returns the first item or creates it and returns it.
  #
  # ==== Alternatives for #find
  #
  #   Person.where(name: 'Spartacus', rating: 4).exists?(conditions = :none)
  #   # returns a boolean indicating if any record with the given conditions exist.
  #
  #   Person.where(name: 'Spartacus', rating: 4).select("field1, field2, field3")
  #   # returns a chainable list of instances with only the mentioned fields.
  #
  #   Person.where(name: 'Spartacus', rating: 4).ids
  #   # returns an Array of ids.
  #
  #   Person.where(name: 'Spartacus', rating: 4).pluck(:field1, :field2)
  #   # returns an Array of the required fields.
  def find: (*untyped args) -> untyped
  # Finds the first record matching the specified conditions. There
  # is no implied ordering so if order matters, you should specify it
  # yourself.
  #
  # If no record is found, returns <tt>nil</tt>.
  #
  #   Post.find_by name: 'Spartacus', rating: 4
  #   Post.find_by "published_at < ?", 2.weeks.ago
  def find_by: (untyped arg, *untyped args) -> untyped
  # Like #find_by, except that if no record is found, raises
  # an ActiveRecord::RecordNotFound error.
  def find_by!: (untyped arg, *untyped args) -> untyped
  # Gives a record (or N records if a parameter is supplied) without any implied
  # order. The order will depend on the database implementation.
  # If an order is supplied it will be respected.
  #
  #   Person.take # returns an object fetched by SELECT * FROM people LIMIT 1
  #   Person.take(5) # returns 5 objects fetched by SELECT * FROM people LIMIT 5
  #   Person.where(["name LIKE '%?'", name]).take
  def take: (?untyped? limit) -> untyped
  # Same as #take but raises ActiveRecord::RecordNotFound if no record
  # is found. Note that #take! accepts no arguments.
  def take!: () -> untyped
  # Find the first record (or first N records if a parameter is supplied).
  # If no order is defined it will order by primary key.
  #
  #   Person.first # returns the first object fetched by SELECT * FROM people ORDER BY people.id LIMIT 1
  #   Person.where(["user_name = ?", user_name]).first
  #   Person.where(["user_name = :u", { u: user_name }]).first
  #   Person.order("created_on DESC").offset(5).first
  #   Person.first(3) # returns the first three objects fetched by SELECT * FROM people ORDER BY people.id LIMIT 3
  #
  def first: (?untyped? limit) -> untyped
  # Same as #first but raises ActiveRecord::RecordNotFound if no record
  # is found. Note that #first! accepts no arguments.
  def first!: () -> untyped
  # Find the last record (or last N records if a parameter is supplied).
  # If no order is defined it will order by primary key.
  #
  #   Person.last # returns the last object fetched by SELECT * FROM people
  #   Person.where(["user_name = ?", user_name]).last
  #   Person.order("created_on DESC").offset(5).last
  #   Person.last(3) # returns the last three objects fetched by SELECT * FROM people.
  #
  # Take note that in that last case, the results are sorted in ascending order:
  #
  #   [#<Person id:2>, #<Person id:3>, #<Person id:4>]
  #
  # and not:
  #
  #   [#<Person id:4>, #<Person id:3>, #<Person id:2>]
  def last: (?untyped? limit) -> untyped
  # Same as #last but raises ActiveRecord::RecordNotFound if no record
  # is found. Note that #last! accepts no arguments.
  def last!: () -> untyped
  # Find the second record.
  # If no order is defined it will order by primary key.
  #
  #   Person.second # returns the second object fetched by SELECT * FROM people
  #   Person.offset(3).second # returns the second object from OFFSET 3 (which is OFFSET 4)
  #   Person.where(["user_name = :u", { u: user_name }]).second
  def second: () -> untyped
  # Same as #second but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def second!: () -> untyped
  # Find the third record.
  # If no order is defined it will order by primary key.
  #
  #   Person.third # returns the third object fetched by SELECT * FROM people
  #   Person.offset(3).third # returns the third object from OFFSET 3 (which is OFFSET 5)
  #   Person.where(["user_name = :u", { u: user_name }]).third
  def third: () -> untyped
  # Same as #third but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def third!: () -> untyped
  # Find the fourth record.
  # If no order is defined it will order by primary key.
  #
  #   Person.fourth # returns the fourth object fetched by SELECT * FROM people
  #   Person.offset(3).fourth # returns the fourth object from OFFSET 3 (which is OFFSET 6)
  #   Person.where(["user_name = :u", { u: user_name }]).fourth
  def fourth: () -> untyped
  # Same as #fourth but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def fourth!: () -> untyped
  # Find the fifth record.
  # If no order is defined it will order by primary key.
  #
  #   Person.fifth # returns the fifth object fetched by SELECT * FROM people
  #   Person.offset(3).fifth # returns the fifth object from OFFSET 3 (which is OFFSET 7)
  #   Person.where(["user_name = :u", { u: user_name }]).fifth
  def fifth: () -> untyped
  # Same as #fifth but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def fifth!: () -> untyped
  # Find the forty-second record. Also known as accessing "the reddit".
  # If no order is defined it will order by primary key.
  #
  #   Person.forty_two # returns the forty-second object fetched by SELECT * FROM people
  #   Person.offset(3).forty_two # returns the forty-second object from OFFSET 3 (which is OFFSET 44)
  #   Person.where(["user_name = :u", { u: user_name }]).forty_two
  def forty_two: () -> untyped
  # Same as #forty_two but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def forty_two!: () -> untyped
  # Find the third-to-last record.
  # If no order is defined it will order by primary key.
  #
  #   Person.third_to_last # returns the third-to-last object fetched by SELECT * FROM people
  #   Person.offset(3).third_to_last # returns the third-to-last object from OFFSET 3
  #   Person.where(["user_name = :u", { u: user_name }]).third_to_last
  def third_to_last: () -> untyped
  # Same as #third_to_last but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def third_to_last!: () -> untyped
  # Find the second-to-last record.
  # If no order is defined it will order by primary key.
  #
  #   Person.second_to_last # returns the second-to-last object fetched by SELECT * FROM people
  #   Person.offset(3).second_to_last # returns the second-to-last object from OFFSET 3
  #   Person.where(["user_name = :u", { u: user_name }]).second_to_last
  def second_to_last: () -> untyped
  # Same as #second_to_last but raises ActiveRecord::RecordNotFound if no record
  # is found.
  def second_to_last!: () -> untyped
  # Returns true if a record exists in the table that matches the +id+ or
  # conditions given, or false otherwise. The argument can take six forms:
  #
  # * Integer - Finds the record with this primary key.
  # * String - Finds the record with a primary key corresponding to this
  #   string (such as <tt>'5'</tt>).
  # * Array - Finds the record that matches these +where+-style conditions
  #   (such as <tt>['name LIKE ?', "%#{query}%"]</tt>).
  # * Hash - Finds the record that matches these +where+-style conditions
  #   (such as <tt>{name: 'David'}</tt>).
  # * +false+ - Returns always +false+.
  # * No args - Returns +false+ if the relation is empty, +true+ otherwise.
  #
  # For more information about specifying conditions as a hash or array,
  # see the Conditions section in the introduction to ActiveRecord::Base.
  #
  # Note: You can't pass in a condition as a string (like <tt>name =
  # 'Jamie'</tt>), since it would be sanitized and then queried against
  # the primary key column, like <tt>id = 'name = \'Jamie\''</tt>.
  #
  #   Person.exists?(5)
  #   Person.exists?('5')
  #   Person.exists?(['name LIKE ?', "%#{query}%"])
  #   Person.exists?(id: [1, 4, 8])
  #   Person.exists?(name: 'David')
  #   Person.exists?(false)
  #   Person.exists?
  #   Person.where(name: 'Spartacus', rating: 4).exists?
  def exists?: (?::Symbol conditions) -> (false | untyped)
  # Returns true if the relation contains the given record or false otherwise.
  #
  # No query is performed if the relation is loaded; the given record is
  # compared to the records in memory. If the relation is unloaded, an
  # efficient existence query is performed, as in #exists?.
  def include?: (untyped record) -> untyped
  alias member? include?
  # This method is called whenever no records are found with either a single
  # id or multiple ids and raises an ActiveRecord::RecordNotFound exception.
  #
  # The error message is different depending on whether a single id or
  # multiple ids are provided. If multiple ids are provided, then the number
  # of results obtained should be provided in the +result_size+ argument and
  # the expected number of results should be provided in the +expected_size+
  # argument.
  def raise_record_not_found_exception!: (?untyped? ids, ?untyped? result_size, ?untyped? expected_size, ?untyped key, ?untyped? not_found_ids) -> untyped
  private def check_reorder_deprecation: () -> (untyped | nil)
  private def construct_relation_for_exists: (untyped conditions) -> untyped
  private def apply_join_dependency: (?eager_loading: untyped) { (untyped, untyped) -> untyped } -> untyped
  private def limited_ids_for: (untyped relation) -> untyped
  private def using_limitable_reflections?: (untyped reflections) -> untyped
  private def find_with_ids: (*untyped ids) -> (::Array[untyped] | untyped)
  private def find_one: (untyped id) -> untyped
  private def find_some: (untyped ids) -> untyped
  private def find_some_ordered: (untyped ids) -> untyped
  private def find_take: () -> untyped
  private def find_take_with_limit: (untyped limit) -> untyped
  private def find_nth: (untyped index) -> untyped
  private def find_nth_with_limit: (untyped index, untyped limit) -> untyped
  private def find_nth_from_last: (untyped index) -> untyped
  private def find_last: (untyped limit) -> untyped
  private def ordered_relation: () -> (untyped | self)
  ONE_AS_ONE: String
end
