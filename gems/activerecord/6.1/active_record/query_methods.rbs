# !!! GENERATED CODE !!!
# Please see generators/rails-generator

module ActiveRecord::QueryMethods
  alias extensions extending_values
  # Specify relationships to be included in the result set. For
  # example:
  #
  #   users = User.includes(:address)
  #   users.each do |user|
  #     user.address.city
  #   end
  #
  # allows you to access the +address+ attribute of the +User+ model without
  # firing an additional query. This will often result in a
  # performance improvement over a simple join.
  #
  # You can also specify multiple relationships, like this:
  #
  #   users = User.includes(:address, :friends)
  #
  # Loading nested relationships is possible using a Hash:
  #
  #   users = User.includes(:address, friends: [:address, :followers])
  #
  # === conditions
  #
  # If you want to add string conditions to your included models, you'll have
  # to explicitly reference them. For example:
  #
  #   User.includes(:posts).where('posts.name = ?', 'example')
  #
  # Will throw an error, but this will work:
  #
  #   User.includes(:posts).where('posts.name = ?', 'example').references(:posts)
  #
  # Note that #includes works with association names while #references needs
  # the actual table name.
  #
  # If you pass the conditions via hash, you don't need to call #references
  # explicitly, as #where references the tables for you. For example, this
  # will work correctly:
  #
  #   User.includes(:posts).where(posts: { name: 'example' })
  def includes: (*untyped args) -> untyped
  def includes!: (*untyped args) -> self
  # Forces eager loading by performing a LEFT OUTER JOIN on +args+:
  #
  #   User.eager_load(:posts)
  #   # SELECT "users"."id" AS t0_r0, "users"."name" AS t0_r1, ...
  #   # FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" =
  #   # "users"."id"
  def eager_load: (*untyped args) -> untyped
  def eager_load!: (*untyped args) -> self
  # Allows preloading of +args+, in the same way that #includes does:
  #
  #   User.preload(:posts)
  #   # SELECT "posts".* FROM "posts" WHERE "posts"."user_id" IN (1, 2, 3)
  def preload: (*untyped args) -> untyped
  def preload!: (*untyped args) -> self
  # Extracts a named +association+ from the relation. The named association is first preloaded,
  # then the individual association records are collected from the relation. Like so:
  #
  #   account.memberships.extract_associated(:user)
  #   # => Returns collection of User records
  #
  # This is short-hand for:
  #
  #   account.memberships.preload(:user).collect(&:user)
  def extract_associated: (untyped association) -> untyped
  # Use to indicate that the given +table_names+ are referenced by an SQL string,
  # and should therefore be JOINed in any query rather than loaded separately.
  # This method only works in conjunction with #includes.
  # See #includes for more details.
  #
  #   User.includes(:posts).where("posts.name = 'foo'")
  #   # Doesn't JOIN the posts table, resulting in an error.
  #
  #   User.includes(:posts).where("posts.name = 'foo'").references(:posts)
  #   # Query now knows the string references posts, so adds a JOIN
  def references: (*untyped table_names) -> untyped
  def references!: (*untyped table_names) -> self
  # Works in two unique ways.
  #
  # First: takes a block so it can be used just like <tt>Array#select</tt>.
  #
  #   Model.all.select { |m| m.field == value }
  #
  # This will build an array of objects from the database for the scope,
  # converting them into an array and iterating through them using
  # <tt>Array#select</tt>.
  #
  # Second: Modifies the SELECT statement for the query so that only certain
  # fields are retrieved:
  #
  #   Model.select(:field)
  #   # => [#<Model id: nil, field: "value">]
  #
  # Although in the above example it looks as though this method returns an
  # array, it actually returns a relation object and can have other query
  # methods appended to it, such as the other methods in ActiveRecord::QueryMethods.
  #
  # The argument to the method can also be an array of fields.
  #
  #   Model.select(:field, :other_field, :and_one_more)
  #   # => [#<Model id: nil, field: "value", other_field: "value", and_one_more: "value">]
  #
  # You can also use one or more strings, which will be used unchanged as SELECT fields.
  #
  #   Model.select('field AS field_one', 'other_field AS field_two')
  #   # => [#<Model id: nil, field: "value", other_field: "value">]
  #
  # If an alias was specified, it will be accessible from the resulting objects:
  #
  #   Model.select('field AS field_one').first.field_one
  #   # => "value"
  #
  # Accessing attributes of an object that do not have fields retrieved by a select
  # except +id+ will throw ActiveModel::MissingAttributeError:
  #
  #   Model.select(:field).first.other_field
  #   # => ActiveModel::MissingAttributeError: missing attribute: other_field
  def select: (*untyped fields) -> untyped
  def _select!: (*untyped fields) -> self
  # Allows you to change a previously set select statement.
  #
  #   Post.select(:title, :body)
  #   # SELECT `posts`.`title`, `posts`.`body` FROM `posts`
  #
  #   Post.select(:title, :body).reselect(:created_at)
  #   # SELECT `posts`.`created_at` FROM `posts`
  #
  # This is short-hand for <tt>unscope(:select).select(fields)</tt>.
  # Note that we're unscoping the entire select statement.
  def reselect: (*untyped args) -> untyped
  # Same as #reselect but operates on relation in-place instead of copying.
  def reselect!: (*untyped args) -> self
  # Allows to specify a group attribute:
  #
  #   User.group(:name)
  #   # SELECT "users".* FROM "users" GROUP BY name
  #
  # Returns an array with distinct records based on the +group+ attribute:
  #
  #   User.select([:id, :name])
  #   # => [#<User id: 1, name: "Oscar">, #<User id: 2, name: "Oscar">, #<User id: 3, name: "Foo">]
  #
  #   User.group(:name)
  #   # => [#<User id: 3, name: "Foo", ...>, #<User id: 2, name: "Oscar", ...>]
  #
  #   User.group('name AS grouped_name, age')
  #   # => [#<User id: 3, name: "Foo", age: 21, ...>, #<User id: 2, name: "Oscar", age: 21, ...>, #<User id: 5, name: "Foo", age: 23, ...>]
  #
  # Passing in an array of attributes to group by is also supported.
  #
  #   User.select([:id, :first_name]).group(:id, :first_name).first(3)
  #   # => [#<User id: 1, first_name: "Bill">, #<User id: 2, first_name: "Earl">, #<User id: 3, first_name: "Beto">]
  def group: (*untyped args) -> untyped
  def group!: (*untyped args) -> self
  # Allows to specify an order attribute:
  #
  #   User.order(:name)
  #   # SELECT "users".* FROM "users" ORDER BY "users"."name" ASC
  #
  #   User.order(email: :desc)
  #   # SELECT "users".* FROM "users" ORDER BY "users"."email" DESC
  #
  #   User.order(:name, email: :desc)
  #   # SELECT "users".* FROM "users" ORDER BY "users"."name" ASC, "users"."email" DESC
  #
  #   User.order('name')
  #   # SELECT "users".* FROM "users" ORDER BY name
  #
  #   User.order('name DESC')
  #   # SELECT "users".* FROM "users" ORDER BY name DESC
  #
  #   User.order('name DESC, email')
  #   # SELECT "users".* FROM "users" ORDER BY name DESC, email
  def order: (*untyped args) -> untyped
  # Same as #order but operates on relation in-place instead of copying.
  def order!: (*untyped args) -> self
  # Replaces any existing order defined on the relation with the specified order.
  #
  #   User.order('email DESC').reorder('id ASC') # generated SQL has 'ORDER BY id ASC'
  #
  # Subsequent calls to order on the same relation will be appended. For example:
  #
  #   User.order('email DESC').reorder('id ASC').order('name ASC')
  #
  # generates a query with 'ORDER BY id ASC, name ASC'.
  def reorder: (*untyped args) -> untyped
  # Same as #reorder but operates on relation in-place instead of copying.
  def reorder!: (*untyped args) -> self
  # Removes an unwanted relation that is already defined on a chain of relations.
  # This is useful when passing around chains of relations and would like to
  # modify the relations without reconstructing the entire chain.
  #
  #   User.order('email DESC').unscope(:order) == User.all
  #
  # The method arguments are symbols which correspond to the names of the methods
  # which should be unscoped. The valid arguments are given in VALID_UNSCOPING_VALUES.
  # The method can also be called with multiple arguments. For example:
  #
  #   User.order('email DESC').select('id').where(name: "John")
  #       .unscope(:order, :select, :where) == User.all
  #
  # One can additionally pass a hash as an argument to unscope specific +:where+ values.
  # This is done by passing a hash with a single key-value pair. The key should be
  # +:where+ and the value should be the where value to unscope. For example:
  #
  #   User.where(name: "John", active: true).unscope(where: :name)
  #       == User.where(active: true)
  #
  # This method is similar to #except, but unlike
  # #except, it persists across merges:
  #
  #   User.order('email').merge(User.except(:order))
  #       == User.order('email')
  #
  #   User.order('email').merge(User.unscope(:order))
  #       == User.all
  #
  # This means it can be used in association definitions:
  #
  #   has_many :comments, -> { unscope(where: :trashed) }
  #
  def unscope: (*untyped args) -> untyped
  def unscope!: (*untyped args) -> self
  # Performs a joins on +args+. The given symbol(s) should match the name of
  # the association(s).
  #
  #   User.joins(:posts)
  #   # SELECT "users".*
  #   # FROM "users"
  #   # INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
  #
  # Multiple joins:
  #
  #   User.joins(:posts, :account)
  #   # SELECT "users".*
  #   # FROM "users"
  #   # INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
  #   # INNER JOIN "accounts" ON "accounts"."id" = "users"."account_id"
  #
  # Nested joins:
  #
  #   User.joins(posts: [:comments])
  #   # SELECT "users".*
  #   # FROM "users"
  #   # INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
  #   # INNER JOIN "comments" ON "comments"."post_id" = "posts"."id"
  #
  # You can use strings in order to customize your joins:
  #
  #   User.joins("LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id")
  #   # SELECT "users".* FROM "users" LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id
  def joins: (*untyped args) -> untyped
  def joins!: (*untyped args) -> self
  # Performs a left outer joins on +args+:
  #
  #   User.left_outer_joins(:posts)
  #   => SELECT "users".* FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id"
  #
  def left_outer_joins: (*untyped args) -> untyped
  alias left_joins left_outer_joins
  def left_outer_joins!: (*untyped args) -> self
  # Returns a new relation, which is the result of filtering the current relation
  # according to the conditions in the arguments.
  #
  # #where accepts conditions in one of several formats. In the examples below, the resulting
  # SQL is given as an illustration; the actual query generated may be different depending
  # on the database adapter.
  #
  # === string
  #
  # A single string, without additional arguments, is passed to the query
  # constructor as an SQL fragment, and used in the where clause of the query.
  #
  #    Client.where("orders_count = '2'")
  #    # SELECT * from clients where orders_count = '2';
  #
  # Note that building your own string from user input may expose your application
  # to injection attacks if not done properly. As an alternative, it is recommended
  # to use one of the following methods.
  #
  # === array
  #
  # If an array is passed, then the first element of the array is treated as a template, and
  # the remaining elements are inserted into the template to generate the condition.
  # Active Record takes care of building the query to avoid injection attacks, and will
  # convert from the ruby type to the database type where needed. Elements are inserted
  # into the string in the order in which they appear.
  #
  #   User.where(["name = ? and email = ?", "Joe", "joe@example.com"])
  #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
  #
  # Alternatively, you can use named placeholders in the template, and pass a hash as the
  # second element of the array. The names in the template are replaced with the corresponding
  # values from the hash.
  #
  #   User.where(["name = :name and email = :email", { name: "Joe", email: "joe@example.com" }])
  #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
  #
  # This can make for more readable code in complex queries.
  #
  # Lastly, you can use sprintf-style % escapes in the template. This works slightly differently
  # than the previous methods; you are responsible for ensuring that the values in the template
  # are properly quoted. The values are passed to the connector for quoting, but the caller
  # is responsible for ensuring they are enclosed in quotes in the resulting SQL. After quoting,
  # the values are inserted using the same escapes as the Ruby core method +Kernel::sprintf+.
  #
  #   User.where(["name = '%s' and email = '%s'", "Joe", "joe@example.com"])
  #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
  #
  # If #where is called with multiple arguments, these are treated as if they were passed as
  # the elements of a single array.
  #
  #   User.where("name = :name and email = :email", { name: "Joe", email: "joe@example.com" })
  #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
  #
  # When using strings to specify conditions, you can use any operator available from
  # the database. While this provides the most flexibility, you can also unintentionally introduce
  # dependencies on the underlying database. If your code is intended for general consumption,
  # test with multiple database backends.
  #
  # === hash
  #
  # #where will also accept a hash condition, in which the keys are fields and the values
  # are values to be searched for.
  #
  # Fields can be symbols or strings. Values can be single values, arrays, or ranges.
  #
  #    User.where({ name: "Joe", email: "joe@example.com" })
  #    # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com'
  #
  #    User.where({ name: ["Alice", "Bob"]})
  #    # SELECT * FROM users WHERE name IN ('Alice', 'Bob')
  #
  #    User.where({ created_at: (Time.now.midnight - 1.day)..Time.now.midnight })
  #    # SELECT * FROM users WHERE (created_at BETWEEN '2012-06-09 07:00:00.000000' AND '2012-06-10 07:00:00.000000')
  #
  # In the case of a belongs_to relationship, an association key can be used
  # to specify the model if an ActiveRecord object is used as the value.
  #
  #    author = Author.find(1)
  #
  #    # The following queries will be equivalent:
  #    Post.where(author: author)
  #    Post.where(author_id: author)
  #
  # This also works with polymorphic belongs_to relationships:
  #
  #    treasure = Treasure.create(name: 'gold coins')
  #    treasure.price_estimates << PriceEstimate.create(price: 125)
  #
  #    # The following queries will be equivalent:
  #    PriceEstimate.where(estimate_of: treasure)
  #    PriceEstimate.where(estimate_of_type: 'Treasure', estimate_of_id: treasure)
  #
  # === Joins
  #
  # If the relation is the result of a join, you may create a condition which uses any of the
  # tables in the join. For string and array conditions, use the table name in the condition.
  #
  #    User.joins(:posts).where("posts.created_at < ?", Time.now)
  #
  # For hash conditions, you can either use the table name in the key, or use a sub-hash.
  #
  #    User.joins(:posts).where({ "posts.published" => true })
  #    User.joins(:posts).where({ posts: { published: true } })
  #
  # === no argument
  #
  # If no argument is passed, #where returns a new instance of WhereChain, that
  # can be chained with #not to return a new relation that negates the where clause.
  #
  #    User.where.not(name: "Jon")
  #    # SELECT * FROM users WHERE name != 'Jon'
  #
  # See WhereChain for more details on #not.
  #
  # === blank condition
  #
  # If the condition is any blank-ish object, then #where is a no-op and returns
  # the current relation.
  def where: (*untyped args) -> (untyped | self | untyped)
  def where!: (untyped opts, *untyped rest) -> self
  # Allows you to change a previously set where condition for a given attribute, instead of appending to that condition.
  #
  #   Post.where(trashed: true).where(trashed: false)
  #   # WHERE `trashed` = 1 AND `trashed` = 0
  #
  #   Post.where(trashed: true).rewhere(trashed: false)
  #   # WHERE `trashed` = 0
  #
  #   Post.where(active: true).where(trashed: true).rewhere(trashed: false)
  #   # WHERE `active` = 1 AND `trashed` = 0
  #
  # This is short-hand for <tt>unscope(where: conditions.keys).where(conditions)</tt>.
  # Note that unlike reorder, we're only unscoping the named conditions -- not the entire where statement.
  def rewhere: (untyped conditions) -> untyped
  # Returns a new relation, which is the logical intersection of this relation and the one passed
  # as an argument.
  #
  # The two relations must be structurally compatible: they must be scoping the same model, and
  # they must differ only by #where (if no #group has been defined) or #having (if a #group is
  # present).
  #
  #    Post.where(id: [1, 2]).and(Post.where(id: [2, 3]))
  #    # SELECT `posts`.* FROM `posts` WHERE `posts`.`id` IN (1, 2) AND `posts`.`id` IN (2, 3)
  #
  def and: (untyped other) -> untyped
  def and!: (untyped other) -> self
  # Returns a new relation, which is the logical union of this relation and the one passed as an
  # argument.
  #
  # The two relations must be structurally compatible: they must be scoping the same model, and
  # they must differ only by #where (if no #group has been defined) or #having (if a #group is
  # present).
  #
  #    Post.where("id = 1").or(Post.where("author_id = 3"))
  #    # SELECT `posts`.* FROM `posts` WHERE ((id = 1) OR (author_id = 3))
  #
  def or: (untyped other) -> untyped
  def or!: (untyped other) -> self
  # Allows to specify a HAVING clause. Note that you can't use HAVING
  # without also specifying a GROUP clause.
  #
  #   Order.having('SUM(price) > 30').group('user_id')
  def having: (untyped opts, *untyped rest) -> (self | untyped)
  def having!: (untyped opts, *untyped rest) -> self
  # Specifies a limit for the number of records to retrieve.
  #
  #   User.limit(10) # generated SQL has 'LIMIT 10'
  #
  #   User.limit(10).limit(20) # generated SQL has 'LIMIT 20'
  def limit: (untyped value) -> untyped
  def limit!: (untyped value) -> self
  # Specifies the number of rows to skip before returning rows.
  #
  #   User.offset(10) # generated SQL has "OFFSET 10"
  #
  # Should be used with order.
  #
  #   User.offset(10).order("name ASC")
  def offset: (untyped value) -> untyped
  def offset!: (untyped value) -> self
  # Specifies locking settings (default to +true+). For more information
  # on locking, please see ActiveRecord::Locking.
  def lock: (?bool locks) -> untyped
  def lock!: (?bool locks) -> self
  # Returns a chainable relation with zero records.
  #
  # The returned relation implements the Null Object pattern. It is an
  # object with defined null behavior and always returns an empty array of
  # records without querying the database.
  #
  # Any subsequent condition chained to the returned relation will continue
  # generating an empty relation and will not fire any query to the database.
  #
  # Used in cases where a method or scope could return zero records but the
  # result needs to be chainable.
  #
  # For example:
  #
  #   @posts = current_user.visible_posts.where(name: params[:name])
  #   # the visible_posts method is expected to return a chainable Relation
  #
  #   def visible_posts
  #     case role
  #     when 'Country Manager'
  #       Post.where(country: country)
  #     when 'Reviewer'
  #       Post.published
  #     when 'Bad User'
  #       Post.none # It can't be chained if [] is returned.
  #     end
  #   end
  #
  def none: () -> untyped
  def none!: () -> untyped
  # Sets readonly attributes for the returned relation. If value is
  # true (default), attempting to update a record will result in an error.
  #
  #   users = User.readonly
  #   users.first.save
  #   => ActiveRecord::ReadOnlyRecord: User is marked as readonly
  def readonly: (?bool value) -> untyped
  def readonly!: (?bool value) -> self
  # Sets the returned relation to strict_loading mode. This will raise an error
  # if the record tries to lazily load an association.
  #
  #   user = User.strict_loading.first
  #   user.comments.to_a
  #   => ActiveRecord::StrictLoadingViolationError
  def strict_loading: (?bool value) -> untyped
  def strict_loading!: (?bool value) -> self
  # Sets attributes to be used when creating new records from a
  # relation object.
  #
  #   users = User.where(name: 'Oscar')
  #   users.new.name # => 'Oscar'
  #
  #   users = users.create_with(name: 'DHH')
  #   users.new.name # => 'DHH'
  #
  # You can pass +nil+ to #create_with to reset attributes:
  #
  #   users = users.create_with(nil)
  #   users.new.name # => 'Oscar'
  def create_with: (untyped value) -> untyped
  def create_with!: (untyped value) -> self
  # Specifies table from which the records will be fetched. For example:
  #
  #   Topic.select('title').from('posts')
  #   # SELECT title FROM posts
  #
  # Can accept other relation objects. For example:
  #
  #   Topic.select('title').from(Topic.approved)
  #   # SELECT title FROM (SELECT * FROM topics WHERE approved = 't') subquery
  #
  #   Topic.select('a.title').from(Topic.approved, :a)
  #   # SELECT a.title FROM (SELECT * FROM topics WHERE approved = 't') a
  #
  def from: (untyped value, ?untyped? subquery_name) -> untyped
  def from!: (untyped value, ?untyped? subquery_name) -> self
  # Specifies whether the records should be unique or not. For example:
  #
  #   User.select(:name)
  #   # Might return two records with the same name
  #
  #   User.select(:name).distinct
  #   # Returns 1 record per distinct name
  #
  #   User.select(:name).distinct.distinct(false)
  #   # You can also remove the uniqueness
  def distinct: (?bool value) -> untyped
  # Like #distinct, but modifies relation in place.
  def distinct!: (?bool value) -> self
  # Used to extend a scope with additional methods, either through
  # a module or through a block provided.
  #
  # The object returned is a relation, which can be further extended.
  #
  # === Using a module
  #
  #   module Pagination
  #     def page(number)
  #       # pagination code goes here
  #     end
  #   end
  #
  #   scope = Model.all.extending(Pagination)
  #   scope.page(params[:page])
  #
  # You can also pass a list of modules:
  #
  #   scope = Model.all.extending(Pagination, SomethingElse)
  #
  # === Using a block
  #
  #   scope = Model.all.extending do
  #     def page(number)
  #       # pagination code goes here
  #     end
  #   end
  #   scope.page(params[:page])
  #
  # You can also use a block and a module list:
  #
  #   scope = Model.all.extending(Pagination) do
  #     def per_page(number)
  #       # pagination code goes here
  #     end
  #   end
  def extending: (*untyped modules) ?{ () -> untyped } -> (untyped | self)
  def extending!: (*untyped modules) ?{ () -> untyped } -> self
  # Specify optimizer hints to be used in the SELECT statement.
  #
  # Example (for MySQL):
  #
  #   Topic.optimizer_hints("MAX_EXECUTION_TIME(50000)", "NO_INDEX_MERGE(topics)")
  #   # SELECT /*+ MAX_EXECUTION_TIME(50000) NO_INDEX_MERGE(topics) */ `topics`.* FROM `topics`
  #
  # Example (for PostgreSQL with pg_hint_plan):
  #
  #   Topic.optimizer_hints("SeqScan(topics)", "Parallel(topics 8)")
  #   # SELECT /*+ SeqScan(topics) Parallel(topics 8) */ "topics".* FROM "topics"
  def optimizer_hints: (*untyped args) -> untyped
  def optimizer_hints!: (*untyped args) -> self
  # Reverse the existing order clause on the relation.
  #
  #   User.order('name ASC').reverse_order # generated SQL has 'ORDER BY name DESC'
  def reverse_order: () -> untyped
  def reverse_order!: () -> self
  def skip_query_cache!: (?bool value) -> self
  def skip_preloading!: () -> self
  # Adds an SQL comment to queries generated from this relation. For example:
  #
  #   User.annotate("selecting user names").select(:name)
  #   # SELECT "users"."name" FROM "users" /* selecting user names */
  #
  #   User.annotate("selecting", "user", "names").select(:name)
  #   # SELECT "users"."name" FROM "users" /* selecting */ /* user */ /* names */
  #
  # The SQL block comment delimiters, "/*" and "*/", will be added automatically.
  def annotate: (*untyped args) -> untyped
  # Like #annotate, but modifies relation in place.
  def annotate!: (*untyped args) -> self
  # Deduplicate multiple values.
  def uniq!: (untyped name) -> self
  # Returns the Arel object associated with the relation.
  def arel: (?untyped? aliases) -> untyped
  def construct_join_dependency: (untyped associations, untyped join_type) -> untyped
  def build_subquery: (untyped subquery_alias, untyped select_value) -> untyped
  def build_where_clause: (untyped opts, ?untyped rest) -> untyped
  alias build_having_clause build_where_clause
  private def lookup_table_klass_from_join_dependencies: (untyped table_name) -> (untyped | nil)
  private def each_join_dependencies: (?untyped join_dependencies) { (untyped) -> untyped } -> untyped
  private def build_join_dependencies: () -> untyped
  private def assert_mutability!: () -> untyped
  private def build_arel: (?untyped? aliases) -> untyped
  private def build_cast_value: (untyped name, untyped value) -> untyped
  private def build_from: () -> untyped
  private def select_association_list: (untyped associations, ?untyped? stashed_joins) { (untyped) -> untyped } -> untyped
  private def build_join_buckets: () -> untyped
  private def build_joins: (untyped join_sources, ?untyped? aliases) -> untyped
  private def build_select: (untyped arel) -> untyped
  private def arel_columns: (untyped columns) -> untyped
  private def arel_column: (untyped field) { (untyped) -> untyped } -> untyped
  private def table_name_matches?: (untyped from) -> untyped
  private def reverse_sql_order: (untyped order_query) -> (::Array[untyped] | untyped)
  private def does_not_support_reverse?: (untyped order) -> untyped
  private def build_order: (untyped arel) -> untyped
  private def validate_order_args: (untyped args) -> untyped
  private def preprocess_order_args: (untyped order_args) -> untyped
  private def sanitize_order_arguments: (untyped order_args) -> untyped
  private def column_references: (untyped order_args) -> untyped
  private def order_column: (untyped field) -> untyped
  private def resolve_arel_attributes: (untyped attrs) -> untyped
  # Checks to make sure that the arguments are not blank. Note that if some
  # blank-like object were initially passed into the query method, then this
  # method will not raise an error.
  #
  # Example:
  #
  #    Post.references()   # raises an error
  #    Post.references([]) # does not raise an error
  #
  # This particular method should be called with a method_name and the args
  # passed into that method as an input. For example:
  #
  # def references(*args)
  #   check_if_method_has_arguments!("references", args)
  #   ...
  # end
  private def check_if_method_has_arguments!: (untyped method_name, untyped args, ?untyped? message) { (untyped) -> untyped } -> untyped
  private def structurally_incompatible_values_for: (untyped other) -> untyped
  include ActiveModel::ForbiddenAttributesProtection
  extend ActiveSupport::Concern
  def includes_values: () -> ::Array[untyped]
  def includes_values=: (::Array[untyped] value) -> ::Array[untyped]
  def eager_load_values: () -> ::Array[untyped]
  def eager_load_values=: (::Array[untyped] value) -> ::Array[untyped]
  def preload_values: () -> ::Array[untyped]
  def preload_values=: (::Array[untyped] value) -> ::Array[untyped]
  def select_values: () -> ::Array[untyped]
  def select_values=: (::Array[untyped] value) -> ::Array[untyped]
  def group_values: () -> ::Array[untyped]
  def group_values=: (::Array[untyped] value) -> ::Array[untyped]
  def order_values: () -> ::Array[untyped]
  def order_values=: (::Array[untyped] value) -> ::Array[untyped]
  def joins_values: () -> ::Array[untyped]
  def joins_values=: (::Array[untyped] value) -> ::Array[untyped]
  def left_outer_joins_values: () -> ::Array[untyped]
  def left_outer_joins_values=: (::Array[untyped] value) -> ::Array[untyped]
  def references_values: () -> ::Array[untyped]
  def references_values=: (::Array[untyped] value) -> ::Array[untyped]
  def extending_values: () -> ::Array[untyped]
  def extending_values=: (::Array[untyped] value) -> ::Array[untyped]
  def unscope_values: () -> ::Array[untyped]
  def unscope_values=: (::Array[untyped] value) -> ::Array[untyped]
  def optimizer_hints_values: () -> ::Array[untyped]
  def optimizer_hints_values=: (::Array[untyped] value) -> ::Array[untyped]
  def annotate_values: () -> ::Array[untyped]
  def annotate_values=: (::Array[untyped] value) -> ::Array[untyped]
  def limit_value: () -> untyped
  def limit_value=: (untyped value) -> untyped
  def offset_value: () -> untyped
  def offset_value=: (untyped value) -> untyped
  def lock_value: () -> untyped
  def lock_value=: (untyped value) -> untyped
  def readonly_value: () -> untyped
  def readonly_value=: (untyped value) -> untyped
  def reordering_value: () -> untyped
  def reordering_value=: (untyped value) -> untyped
  def strict_loading_value: () -> untyped
  def strict_loading_value=: (untyped value) -> untyped
  def reverse_order_value: () -> untyped
  def reverse_order_value=: (untyped value) -> untyped
  def distinct_value: () -> untyped
  def distinct_value=: (untyped value) -> untyped
  def create_with_value: () -> ::Hash[untyped, untyped]?
  def create_with_value=: (::Hash[untyped, untyped]? value) -> ::Hash[untyped, untyped]?
  def skip_query_cache_value: () -> untyped
  def skip_query_cache_value=: (untyped value) -> untyped
  def where_clause: () -> ::ActiveRecord::Relation::WhereClause
  def where_clause=: (::ActiveRecord::Relation::WhereClause value) -> ::ActiveRecord::Relation::WhereClause
  def having_clause: () -> ::ActiveRecord::Relation::WhereClause
  def having_clause=: (::ActiveRecord::Relation::WhereClause value) -> ::ActiveRecord::Relation::WhereClause
  def from_clause: () -> ::ActiveRecord::Relation::FromClause
  def from_clause=: (::ActiveRecord::Relation::FromClause value) -> ::ActiveRecord::Relation::FromClause
  FROZEN_EMPTY_ARRAY: Array[untyped]
  FROZEN_EMPTY_HASH: Hash[untyped, untyped]
  STRUCTURAL_VALUE_METHODS: Array[Symbol]
  VALID_DIRECTIONS: Set[Symbol | String]
  VALID_UNSCOPING_VALUES: Set[Symbol]
end
