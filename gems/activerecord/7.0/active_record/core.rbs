# !!! GENERATED CODE !!!
# Please see generators/rails-generator

module ActiveRecord::Core
  #
  # Contains the database configuration - as is typically stored in config/database.yml -
  # as an ActiveRecord::DatabaseConfigurations object.
  #
  # For example, the following database.yml...
  #
  #   development:
  #     adapter: sqlite3
  #     database: db/development.sqlite3
  #
  #   production:
  #     adapter: sqlite3
  #     database: db/production.sqlite3
  #
  # ...would result in ActiveRecord::Base.configurations to look like this:
  #
  #   #<ActiveRecord::DatabaseConfigurations:0x00007fd1acbdf800 @configurations=[
  #     #<ActiveRecord::DatabaseConfigurations::HashConfig:0x00007fd1acbded10 @env_name="development",
  #       @name="primary", @config={adapter: "sqlite3", database: "db/development.sqlite3"}>,
  #     #<ActiveRecord::DatabaseConfigurations::HashConfig:0x00007fd1acbdea90 @env_name="production",
  #       @name="primary", @config={adapter: "sqlite3", database: "db/production.sqlite3"}>
  #   ]>
  def self.configurations=: (untyped config) -> untyped
  # Returns fully resolved ActiveRecord::DatabaseConfigurations object
  def self.configurations: () -> untyped
  def self.application_record_class?: () -> (untyped | true | nil)
  def self.connection_handler: () -> untyped
  def self.connection_handler=: (untyped handler) -> untyped
  def self.connection_handlers: () -> untyped
  def self.connection_handlers=: (untyped handlers) -> untyped
  def self.asynchronous_queries_session: () -> untyped
  def self.asynchronous_queries_tracker: () -> untyped
  # Returns the symbol representing the current connected role.
  #
  #   ActiveRecord::Base.connected_to(role: :writing) do
  #     ActiveRecord::Base.current_role #=> :writing
  #   end
  #
  #   ActiveRecord::Base.connected_to(role: :reading) do
  #     ActiveRecord::Base.current_role #=> :reading
  #   end
  def self.current_role: () -> untyped
  # Returns the symbol representing the current connected shard.
  #
  #   ActiveRecord::Base.connected_to(role: :reading) do
  #     ActiveRecord::Base.current_shard #=> :default
  #   end
  #
  #   ActiveRecord::Base.connected_to(role: :writing, shard: :one) do
  #     ActiveRecord::Base.current_shard #=> :one
  #   end
  def self.current_shard: () -> untyped
  # Returns the symbol representing the current setting for
  # preventing writes.
  #
  #   ActiveRecord::Base.connected_to(role: :reading) do
  #     ActiveRecord::Base.current_preventing_writes #=> true
  #   end
  #
  #   ActiveRecord::Base.connected_to(role: :writing) do
  #     ActiveRecord::Base.current_preventing_writes #=> false
  #   end
  def self.current_preventing_writes: () -> (untyped | untyped | false)
  def self.connected_to_stack: () -> untyped
  def self.connection_class=: (untyped b) -> untyped
  def self.connection_class: () -> untyped
  def self.connection_class?: () -> untyped
  def self.connection_class_for_self: () -> untyped
  def self.strict_loading_violation!: (owner: untyped, reflection: untyped) -> untyped
  # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with
  # attributes but not yet saved (pass a hash with key names matching the associated table column names).
  # In both instances, valid attribute keys are determined by the column names of the associated table --
  # hence you can't have attributes that aren't part of the table columns.
  #
  # ==== Example:
  #   # Instantiates a single new object
  #   User.new(first_name: 'Jamie')
  def initialize: (?untyped? attributes) { (untyped) -> untyped } -> void
  # Initialize an empty model object from +coder+. +coder+ should be
  # the result of previously encoding an Active Record model, using
  # #encode_with.
  #
  #   class Post < ActiveRecord::Base
  #   end
  #
  #   old_post = Post.new(title: "hello world")
  #   coder = {}
  #   old_post.encode_with(coder)
  #
  #   post = Post.allocate
  #   post.init_with(coder)
  #   post.title # => 'hello world'
  def init_with: (untyped coder) ?{ () -> untyped } -> untyped
  #
  # Initialize an empty model object from +attributes+.
  # +attributes+ should be an attributes object, and unlike the
  # `initialize` method, no assignment calls are made per attribute.
  def init_with_attributes: (untyped attributes, ?bool new_record) { (untyped) -> untyped } -> self
  #
  def initialize_dup: (untyped other) -> untyped
  # Populate +coder+ with attributes about this record that should be
  # serialized. The structure of +coder+ defined in this method is
  # guaranteed to match the structure of +coder+ passed to the #init_with
  # method.
  #
  # Example:
  #
  #   class Post < ActiveRecord::Base
  #   end
  #   coder = {}
  #   Post.new.encode_with(coder)
  #   coder # => {"attributes" => {"id" => nil, ... }}
  def encode_with: (untyped coder) -> untyped
  # Returns true if +comparison_object+ is the same exact object, or +comparison_object+
  # is of the same type and +self+ has an ID and it is equal to +comparison_object.id+.
  #
  # Note that new records are different from any other record by definition, unless the
  # other record is the receiver itself. Besides, if you fetch existing records with
  # +select+ and leave the ID out, you're on your own, this predicate will return false.
  #
  # Note also that destroying a record preserves its ID in the model instance, so deleted
  # models are still comparable.
  def ==: (untyped comparison_object) -> untyped
  alias eql? ==
  # Delegates to id in order to allow two records of the same type and id to work with something like:
  #   [ Person.find(1), Person.find(2), Person.find(3) ] & [ Person.find(1), Person.find(4) ] # => [ Person.find(1) ]
  def hash: () -> untyped
  # Clone and freeze the attributes hash such that associations are still
  # accessible, even on destroyed records, but cloned models will not be
  # frozen.
  def freeze: () -> self
  # Returns +true+ if the attributes hash has been frozen.
  def frozen?: () -> untyped
  # Allows sort on objects
  def <=>: (untyped other_object) -> untyped
  def present?: () -> true
  def blank?: () -> false
  # Returns +true+ if the record is read only.
  def readonly?: () -> untyped
  # Returns +true+ if the record is in strict_loading mode.
  def strict_loading?: () -> untyped
  # Sets the record to strict_loading mode. This will raise an error
  # if the record tries to lazily load an association.
  #
  #   user = User.first
  #   user.strict_loading! # => true
  #   user.comments
  #   => ActiveRecord::StrictLoadingViolationError
  #
  # === Parameters:
  #
  # * value - Boolean specifying whether to enable or disable strict loading.
  # * mode - Symbol specifying strict loading mode. Defaults to :all. Using
  #          :n_plus_one_only mode will only raise an error if an association
  #          that will lead to an n plus one query is lazily loaded.
  #
  # === Example:
  #
  #   user = User.first
  #   user.strict_loading!(false) # => false
  #   user.comments
  #   => #<ActiveRecord::Associations::CollectionProxy>
  def strict_loading!: (?bool value, ?mode: ::Symbol) -> untyped
  # Returns +true+ if the record uses strict_loading with +:n_plus_one_only+ mode enabled.
  def strict_loading_n_plus_one_only?: () -> untyped
  # Marks this record as read only.
  def readonly!: () -> untyped
  def connection_handler: () -> untyped
  # Returns the contents of the record as a nicely formatted string.
  def inspect: () -> ::String
  # Takes a PP and prettily prints this record to it, allowing you to get a nice result from <tt>pp record</tt>
  # when pp is required.
  def pretty_print: (untyped pp) -> untyped
  # Returns a hash of the given methods with their names as keys and returned values as values.
  def slice: (*untyped methods) -> untyped
  # Returns an array of the values returned by the given methods.
  def values_at: (*untyped methods) -> untyped
  # +Array#flatten+ will call +#to_ary+ (recursively) on each of the elements of
  # the array, and then rescues from the possible +NoMethodError+. If those elements are
  # +ActiveRecord::Base+'s, then this triggers the various +method_missing+'s that we have,
  # which significantly impacts upon performance.
  #
  # So we can avoid the +method_missing+ hit by explicitly defining +#to_ary+ as +nil+ here.
  #
  # See also https://tenderlovemaking.com/2011/06/28/til-its-ok-to-return-nil-from-to_ary.html
  private def to_ary: () -> nil
  private def init_internals: () -> untyped
  private def initialize_internals_callback: () -> nil
  private def custom_inspect_method_defined?: () -> untyped
  private def inspection_filter: () -> untyped
  extend ActiveSupport::Concern
  attr_reader strict_loading_mode: untyped
end
