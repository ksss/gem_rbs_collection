# !!! GENERATED CODE !!!
# Please see generators/rails-generator

class ActiveRecord::QueryMethods::WhereChain
  def initialize: (untyped scope) -> void
  # Returns a new relation expressing WHERE + NOT condition according to
  # the conditions in the arguments.
  #
  # #not accepts conditions as a string, array, or hash. See QueryMethods#where for
  # more details on each format.
  #
  #    User.where.not("name = 'Jon'")
  #    # SELECT * FROM users WHERE NOT (name = 'Jon')
  #
  #    User.where.not(["name = ?", "Jon"])
  #    # SELECT * FROM users WHERE NOT (name = 'Jon')
  #
  #    User.where.not(name: "Jon")
  #    # SELECT * FROM users WHERE name != 'Jon'
  #
  #    User.where.not(name: nil)
  #    # SELECT * FROM users WHERE name IS NOT NULL
  #
  #    User.where.not(name: %w(Ko1 Nobu))
  #    # SELECT * FROM users WHERE name NOT IN ('Ko1', 'Nobu')
  #
  #    User.where.not(name: "Jon", role: "admin")
  #    # SELECT * FROM users WHERE NOT (name == 'Jon' AND role == 'admin')
  #
  # If there is a non-nil condition on a nullable column in the hash condition, the records that have
  # nil values on the nullable column won't be returned.
  #    User.create!(nullable_country: nil)
  #    User.where.not(nullable_country: "UK")
  #    # SELECT * FROM users WHERE NOT (nullable_country = 'UK')
  #    # => []
  def not: (untyped opts, *untyped rest) -> untyped
  # Returns a new relation with joins and where clause to identify
  # associated relations.
  #
  # For example, posts that are associated to a related author:
  #
  #    Post.where.associated(:author)
  #    # SELECT "posts".* FROM "posts"
  #    # INNER JOIN "authors" ON "authors"."id" = "posts"."author_id"
  #    # WHERE "authors"."id" IS NOT NULL
  #
  # Additionally, multiple relations can be combined. This will return posts
  # associated to both an author and any comments:
  #
  #    Post.where.associated(:author, :comments)
  #    # SELECT "posts".* FROM "posts"
  #    # INNER JOIN "authors" ON "authors"."id" = "posts"."author_id"
  #    # INNER JOIN "comments" ON "comments"."post_id" = "posts"."id"
  #    # WHERE "authors"."id" IS NOT NULL AND "comments"."id" IS NOT NULL
  def associated: (*untyped associations) -> untyped
  # Returns a new relation with left outer joins and where clause to identify
  # missing relations.
  #
  # For example, posts that are missing a related author:
  #
  #    Post.where.missing(:author)
  #    # SELECT "posts".* FROM "posts"
  #    # LEFT OUTER JOIN "authors" ON "authors"."id" = "posts"."author_id"
  #    # WHERE "authors"."id" IS NULL
  #
  # Additionally, multiple relations can be combined. This will return posts
  # that are missing both an author and any comments:
  #
  #    Post.where.missing(:author, :comments)
  #    # SELECT "posts".* FROM "posts"
  #    # LEFT OUTER JOIN "authors" ON "authors"."id" = "posts"."author_id"
  #    # LEFT OUTER JOIN "comments" ON "comments"."post_id" = "posts"."id"
  #    # WHERE "authors"."id" IS NULL AND "comments"."id" IS NULL
  def missing: (*untyped associations) -> untyped
  private def scope_association_reflection: (untyped association) -> untyped
end
