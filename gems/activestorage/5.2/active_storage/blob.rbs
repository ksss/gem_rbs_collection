# !!! GENERATED CODE !!!
# Please see generators/rails-generator

class ActiveStorage::Blob < ::ActiveRecord::Base
  # You can used the signed ID of a blob to refer to it on the client side without fear of tampering.
  # This is particularly helpful for direct uploads where the client-side needs to refer to the blob
  # that was created ahead of the upload itself on form submission.
  #
  # The signed ID is also used to create stable URLs for the blob through the BlobsController.
  def self.find_signed: (untyped id) -> untyped
  # Returns a new, unsaved blob instance after the +io+ has been uploaded to the service.
  def self.build_after_upload: (io: untyped, filename: untyped, ?content_type: untyped?, ?metadata: untyped?) -> untyped
  # Returns a saved blob instance after the +io+ has been uploaded to the service. Note, the blob is first built,
  # then the +io+ is uploaded, then the blob is saved. This is done this way to avoid uploading (which may take
  # time), while having an open database transaction.
  def self.create_after_upload!: (io: untyped, filename: untyped, ?content_type: untyped?, ?metadata: untyped?) -> untyped
  # Returns a saved blob _without_ uploading a file to the service. This blob will point to a key where there is
  # no file yet. It's intended to be used together with a client-side upload, which will first create the blob
  # in order to produce the signed URL for uploading. This signed URL points to the key generated by the blob.
  # Once the form using the direct upload is submitted, the blob can be associated with the right record using
  # the signed ID.
  def self.create_before_direct_upload!: (filename: untyped, byte_size: untyped, checksum: untyped, ?content_type: untyped?, ?metadata: untyped?) -> untyped
  # Returns a signed ID for this blob that's suitable for reference on the client-side without fear of tampering.
  # It uses the framework-wide verifier on <tt>ActiveStorage.verifier</tt>, but with a dedicated purpose.
  def signed_id: () -> untyped
  # Returns the key pointing to the file on the service that's associated with this blob. The key is in the
  # standard secure-token format from Rails. So it'll look like: XTAPjJCJiuDrLk3TmwyJGpUo. This key is not intended
  # to be revealed directly to the user. Always refer to blobs using the signed_id or a verified form of the key.
  def key: () -> untyped
  # Returns an ActiveStorage::Filename instance of the filename that can be
  # queried for basename, extension, and a sanitized version of the filename
  # that's safe to use in URLs.
  def filename: () -> untyped
  # Returns true if the content_type of this blob is in the image range, like image/png.
  def image?: () -> untyped
  # Returns true if the content_type of this blob is in the audio range, like audio/mpeg.
  def audio?: () -> untyped
  # Returns true if the content_type of this blob is in the video range, like video/mp4.
  def video?: () -> untyped
  # Returns true if the content_type of this blob is in the text range, like text/plain.
  def text?: () -> untyped
  # Returns the URL of the blob on the service. This URL is intended to be short-lived for security and not used directly
  # with users. Instead, the +service_url+ should only be exposed as a redirect from a stable, possibly authenticated URL.
  # Hiding the +service_url+ behind a redirect also gives you the power to change services without updating all URLs. And
  # it allows permanent URLs that redirect to the +service_url+ to be cached in the view.
  def service_url: (?expires_in: untyped, ?disposition: ::Symbol, ?filename: untyped?, **untyped options) -> untyped
  # Returns a URL that can be used to directly upload a file for this blob on the service. This URL is intended to be
  # short-lived for security and only generated on-demand by the client-side JavaScript responsible for doing the uploading.
  def service_url_for_direct_upload: (?expires_in: untyped) -> untyped
  # Returns a Hash of headers for +service_url_for_direct_upload+ requests.
  def service_headers_for_direct_upload: () -> untyped
  # Uploads the +io+ to the service on the +key+ for this blob. Blobs are intended to be immutable, so you shouldn't be
  # using this method after a file has already been uploaded to fit with a blob. If you want to create a derivative blob,
  # you should instead simply create a new blob based on the old one.
  #
  # Prior to uploading, we compute the checksum, which is sent to the service for transit integrity validation. If the
  # checksum does not match what the service receives, an exception will be raised. We also measure the size of the +io+
  # and store that in +byte_size+ on the blob record.
  #
  # Normally, you do not have to call this method directly at all. Use the factory class methods of +build_after_upload+
  # and +create_after_upload!+.
  def upload: (untyped io) -> untyped
  # Downloads the file associated with this blob. If no block is given, the entire file is read into memory and returned.
  # That'll use a lot of RAM for very large files. If a block is given, then the download is streamed and yielded in chunks.
  def download: () ?{ () -> untyped } -> untyped
  # Deletes the file on the service that's associated with this blob. This should only be done if the blob is going to be
  # deleted as well or you will essentially have a dead reference. It's recommended to use the +#purge+ and +#purge_later+
  # methods in most circumstances.
  def delete: () -> untyped
  # Deletes the file on the service and then destroys the blob record. This is the recommended way to dispose of unwanted
  # blobs. Note, though, that deleting the file off the service will initiate a HTTP connection to the service, which may
  # be slow or prevented, so you should not use this method inside a transaction or in callbacks. Use +#purge_later+ instead.
  def purge: () -> untyped
  # Enqueues an ActiveStorage::PurgeJob job that'll call +purge+. This is the recommended way to purge blobs when the call
  # needs to be made from a transaction, a callback, or any other real-time scenario.
  def purge_later: () -> untyped
  private def compute_checksum_in_chunks: (untyped io) -> untyped
  private def extract_content_type: (untyped io) -> untyped
  private def forcibly_serve_as_binary?: () -> untyped
  private def allowed_inline?: () -> untyped
  private def content_type_for_service_url: () -> untyped
  private def forced_disposition_for_service_url: () -> (:attachment | nil)
  private def service_metadata: () -> ({ content_type: untyped, disposition: :attachment, filename: untyped } | { content_type: untyped, disposition: :attachment, filename: untyped } | { content_type: untyped })
end
