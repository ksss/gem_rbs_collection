# !!! GENERATED CODE !!!
# Please see generators/rails-generator

module Enumerable[unchecked out Elem] : ::_Each[Elem]
  def as_json: (?untyped? options) -> untyped

  # We can't use Refinements here because Refinements with Module which will be prepended
  # doesn't work well https://bugs.ruby-lang.org/issues/13446
  alias _original_sum_with_required_identity sum

  # Convert an enumerable to a hash.
  #
  #   people.index_by(&:login)
  #   # => { "nextangle" => <Person ...>, "chade-" => <Person ...>, ...}
  #   people.index_by { |person| "#{person.first_name} #{person.last_name}" }
  #   # => { "Chade- Fowlersburg-e" => <Person ...>, "David Heinemeier Hansson" => <Person ...>, ...}
  def index_by: () { (untyped) -> untyped } -> untyped

  # Returns +true+ if the enumerable has more than 1 element. Functionally
  # equivalent to <tt>enum.to_a.size > 1</tt>. Can be called with a block too,
  # much like any?, so <tt>people.many? { |p| p.age > 26 }</tt> returns +true+
  # if more than one person is over 26.
  def many?: () { (untyped) -> untyped } -> untyped

  # The negative of the <tt>Enumerable#include?</tt>. Returns +true+ if the
  # collection does not include the object.
  def exclude?: (untyped object) -> untyped

  # Returns a copy of the enumerable without the specified elements.
  #
  #   ["David", "Rafael", "Aaron", "Todd"].without "Aaron", "Todd"
  #   # => ["David", "Rafael"]
  #
  #   {foo: 1, bar: 2, baz: 3}.without :bar
  #   # => {foo: 1, baz: 3}
  def without: (*untyped elements) -> untyped

  # Convert an enumerable to an array based on the given key.
  #
  #   [{ name: "David" }, { name: "Rafael" }, { name: "Aaron" }].pluck(:name)
  #   # => ["David", "Rafael", "Aaron"]
  #
  #   [{ id: 1, name: "David" }, { id: 2, name: "Rafael" }].pluck(:id, :name)
  #   # => [[1, "David"], [2, "Rafael"]]
  def pluck: (*untyped keys) -> untyped

  prepend ActiveSupport::ToJsonWithActiveSupportEncoder
end
