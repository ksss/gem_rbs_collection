# !!! GENERATED CODE !!!
# Please see generators/rails-generator

class Hash[unchecked out K, unchecked out V]
  # By default, only instances of Hash itself are extractable.
  # Subclasses of Hash may implement this method and return
  # true to declare themselves as extractable. If a Hash
  # is extractable, Array#extract_options! pops it from
  # the Array when it is the last element of the Array.
  def extractable_options?: () -> untyped
  # Hash#reject has its own definition, so this needs one too.
  def compact_blank: () -> untyped
  # Removes all blank values from the +Hash+ in place and returns self.
  # Uses Object#blank? for determining if a value is blank.
  #
  #    h = { a: "", b: 1, c: nil, d: [], e: false, f: true }
  #    h.compact_blank!
  #    # => { b: 1, f: true }
  def compact_blank!: () -> untyped
  # Returns a string containing an XML representation of its receiver:
  #
  #   { foo: 1, bar: 2 }.to_xml
  #   # =>
  #   # <?xml version="1.0" encoding="UTF-8"?>
  #   # <hash>
  #   #   <foo type="integer">1</foo>
  #   #   <bar type="integer">2</bar>
  #   # </hash>
  #
  # To do so, the method loops over the pairs and builds nodes that depend on
  # the _values_. Given a pair +key+, +value+:
  #
  # * If +value+ is a hash there's a recursive call with +key+ as <tt>:root</tt>.
  #
  # * If +value+ is an array there's a recursive call with +key+ as <tt>:root</tt>,
  #   and +key+ singularized as <tt>:children</tt>.
  #
  # * If +value+ is a callable object it must expect one or two arguments. Depending
  #   on the arity, the callable is invoked with the +options+ hash as first argument
  #   with +key+ as <tt>:root</tt>, and +key+ singularized as second argument. The
  #   callable can add nodes by using <tt>options[:builder]</tt>.
  #
  #     {foo: lambda { |options, key| options[:builder].b(key) }}.to_xml
  #     # => "<b>foo</b>"
  #
  # * If +value+ responds to +to_xml+ the method is invoked with +key+ as <tt>:root</tt>.
  #
  #     class Foo
  #       def to_xml(options)
  #         options[:builder].bar 'fooing!'
  #       end
  #     end
  #
  #     { foo: Foo.new }.to_xml(skip_instruct: true)
  #     # =>
  #     # <hash>
  #     #   <bar>fooing!</bar>
  #     # </hash>
  #
  # * Otherwise, a node with +key+ as tag is created with a string representation of
  #   +value+ as text node. If +value+ is +nil+ an attribute "nil" set to "true" is added.
  #   Unless the option <tt>:skip_types</tt> exists and is true, an attribute "type" is
  #   added as well according to the following mapping:
  #
  #     XML_TYPE_NAMES = {
  #       "Symbol"     => "symbol",
  #       "Integer"    => "integer",
  #       "BigDecimal" => "decimal",
  #       "Float"      => "float",
  #       "TrueClass"  => "boolean",
  #       "FalseClass" => "boolean",
  #       "Date"       => "date",
  #       "DateTime"   => "dateTime",
  #       "Time"       => "dateTime"
  #     }
  #
  # By default the root node is "hash", but that's configurable via the <tt>:root</tt> option.
  #
  # The default XML builder is a fresh instance of <tt>Builder::XmlMarkup</tt>. You can
  # configure your own builder with the <tt>:builder</tt> option. The method also accepts
  # options like <tt>:dasherize</tt> and friends, they are forwarded to the builder.
  def to_xml: (?::Hash[untyped, untyped] options) { (untyped) -> untyped } -> untyped
  # Returns a Hash containing a collection of pairs when the key is the node name and the value is
  # its content
  #
  #   xml = <<-XML
  #     <?xml version="1.0" encoding="UTF-8"?>
  #       <hash>
  #         <foo type="integer">1</foo>
  #         <bar type="integer">2</bar>
  #       </hash>
  #   XML
  #
  #   hash = Hash.from_xml(xml)
  #   # => {"hash"=>{"foo"=>1, "bar"=>2}}
  #
  # +DisallowedType+ is raised if the XML contains attributes with <tt>type="yaml"</tt> or
  # <tt>type="symbol"</tt>. Use <tt>Hash.from_trusted_xml</tt> to
  # parse this XML.
  #
  # Custom +disallowed_types+ can also be passed in the form of an
  # array.
  #
  #   xml = <<-XML
  #     <?xml version="1.0" encoding="UTF-8"?>
  #       <hash>
  #         <foo type="integer">1</foo>
  #         <bar type="string">"David"</bar>
  #       </hash>
  #   XML
  #
  #   hash = Hash.from_xml(xml, ['integer'])
  #   # => ActiveSupport::XMLConverter::DisallowedType: Disallowed type attribute: "integer"
  #
  # Note that passing custom disallowed types will override the default types,
  # which are Symbol and YAML.
  def self.from_xml: (untyped xml, ?untyped? disallowed_types) -> untyped
  # Builds a Hash from XML just like <tt>Hash.from_xml</tt>, but also allows Symbol and YAML.
  def self.from_trusted_xml: (untyped xml) -> untyped
  # Returns a new hash with +self+ and +other_hash+ merged recursively.
  #
  #   h1 = { a: true, b: { c: [1, 2, 3] } }
  #   h2 = { a: false, b: { x: [3, 4, 5] } }
  #
  #   h1.deep_merge(h2) # => { a: false, b: { c: [1, 2, 3], x: [3, 4, 5] } }
  #
  # Like with Hash#merge in the standard library, a block can be provided
  # to merge values:
  #
  #   h1 = { a: 100, b: 200, c: { c1: 100 } }
  #   h2 = { b: 250, c: { c1: 200 } }
  #   h1.deep_merge(h2) { |key, this_val, other_val| this_val + other_val }
  #   # => { a: 100, b: 450, c: { c1: 300 } }
  def deep_merge: (untyped other_hash) ?{ () -> untyped } -> untyped
  # Same as +deep_merge+, but modifies +self+.
  def deep_merge!: (untyped other_hash) ?{ () -> untyped } -> untyped
  # Returns a new hash with all values converted by the block operation.
  # This includes the values from the root hash and from all
  # nested hashes and arrays.
  #
  #  hash = { person: { name: 'Rob', age: '28' } }
  #
  #  hash.deep_transform_values{ |value| value.to_s.upcase }
  #  # => {person: {name: "ROB", age: "28"}}
  def deep_transform_values: () ?{ () -> untyped } -> untyped
  # Destructively converts all values by using the block operation.
  # This includes the values from the root hash and from all
  # nested hashes and arrays.
  def deep_transform_values!: () ?{ () -> untyped } -> untyped
  # Support methods for deep transforming nested hashes and arrays.
  private def _deep_transform_values_in_object: (untyped object) { (untyped) -> untyped } -> untyped
  private def _deep_transform_values_in_object!: (untyped object) { (untyped) -> untyped } -> untyped
  # Removes the given keys from hash and returns it.
  #   hash = { a: true, b: false, c: nil }
  #   hash.except!(:c) # => { a: true, b: false }
  #   hash             # => { a: true, b: false }
  def except!: (*untyped keys) -> self
  # Returns an <tt>ActiveSupport::HashWithIndifferentAccess</tt> out of its receiver:
  #
  #   { a: 1 }.with_indifferent_access['a'] # => 1
  def with_indifferent_access: () -> untyped
  # Called when object is nested under an object that receives
  # #with_indifferent_access. This method will be called on the current object
  # by the enclosing object and is aliased to #with_indifferent_access by
  # default. Subclasses of Hash may overwrite this method to return +self+ if
  # converting to an <tt>ActiveSupport::HashWithIndifferentAccess</tt> would not be
  # desirable.
  #
  #   b = { b: 1 }
  #   { a: b }.with_indifferent_access['a'] # calls b.nested_under_indifferent_access
  #   # => {"b"=>1}
  alias nested_under_indifferent_access with_indifferent_access
  # Returns a new hash with all keys converted to strings.
  #
  #   hash = { name: 'Rob', age: '28' }
  #
  #   hash.stringify_keys
  #   # => {"name"=>"Rob", "age"=>"28"}
  def stringify_keys: () -> untyped
  # Destructively converts all keys to strings. Same as
  # +stringify_keys+, but modifies +self+.
  def stringify_keys!: () -> untyped
  # Returns a new hash with all keys converted to symbols, as long as
  # they respond to +to_sym+.
  #
  #   hash = { 'name' => 'Rob', 'age' => '28' }
  #
  #   hash.symbolize_keys
  #   # => {:name=>"Rob", :age=>"28"}
  def symbolize_keys: () -> untyped
  alias to_options symbolize_keys
  # Destructively converts all keys to symbols, as long as they respond
  # to +to_sym+. Same as +symbolize_keys+, but modifies +self+.
  def symbolize_keys!: () -> untyped
  alias to_options! symbolize_keys!
  # Validates all keys in a hash match <tt>*valid_keys</tt>, raising
  # +ArgumentError+ on a mismatch.
  #
  # Note that keys are treated differently than HashWithIndifferentAccess,
  # meaning that string and symbol keys will not match.
  #
  #   { name: 'Rob', years: '28' }.assert_valid_keys(:name, :age) # => raises "ArgumentError: Unknown key: :years. Valid keys are: :name, :age"
  #   { name: 'Rob', age: '28' }.assert_valid_keys('name', 'age') # => raises "ArgumentError: Unknown key: :name. Valid keys are: 'name', 'age'"
  #   { name: 'Rob', age: '28' }.assert_valid_keys(:name, :age)   # => passes, raises nothing
  def assert_valid_keys: (*untyped valid_keys) -> untyped
  # Returns a new hash with all keys converted by the block operation.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  #
  #  hash = { person: { name: 'Rob', age: '28' } }
  #
  #  hash.deep_transform_keys{ |key| key.to_s.upcase }
  #  # => {"PERSON"=>{"NAME"=>"Rob", "AGE"=>"28"}}
  def deep_transform_keys: () ?{ () -> untyped } -> untyped
  # Destructively converts all keys by using the block operation.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  def deep_transform_keys!: () ?{ () -> untyped } -> untyped
  # Returns a new hash with all keys converted to strings.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  #
  #   hash = { person: { name: 'Rob', age: '28' } }
  #
  #   hash.deep_stringify_keys
  #   # => {"person"=>{"name"=>"Rob", "age"=>"28"}}
  def deep_stringify_keys: () -> untyped
  # Destructively converts all keys to strings.
  # This includes the keys from the root hash and from all
  # nested hashes and arrays.
  def deep_stringify_keys!: () -> untyped
  # Returns a new hash with all keys converted to symbols, as long as
  # they respond to +to_sym+. This includes the keys from the root hash
  # and from all nested hashes and arrays.
  #
  #   hash = { 'person' => { 'name' => 'Rob', 'age' => '28' } }
  #
  #   hash.deep_symbolize_keys
  #   # => {:person=>{:name=>"Rob", :age=>"28"}}
  def deep_symbolize_keys: () -> untyped
  # Destructively converts all keys to symbols, as long as they respond
  # to +to_sym+. This includes the keys from the root hash and from all
  # nested hashes and arrays.
  def deep_symbolize_keys!: () -> untyped
  # Support methods for deep transforming nested hashes and arrays.
  private def _deep_transform_keys_in_object: (untyped object) { (untyped) -> untyped } -> untyped
  private def _deep_transform_keys_in_object!: (untyped object) { (untyped) -> untyped } -> untyped
  # Merges the caller into +other_hash+. For example,
  #
  #   options = options.reverse_merge(size: 25, velocity: 10)
  #
  # is equivalent to
  #
  #   options = { size: 25, velocity: 10 }.merge(options)
  #
  # This is particularly useful for initializing an options hash
  # with default values.
  def reverse_merge: (untyped other_hash) -> untyped
  alias with_defaults reverse_merge
  # Destructive +reverse_merge+.
  def reverse_merge!: (untyped other_hash) -> untyped
  alias reverse_update reverse_merge!
  alias with_defaults! reverse_merge!
  # Replaces the hash with only the given keys.
  # Returns a hash containing the removed key/value pairs.
  #
  #   hash = { a: 1, b: 2, c: 3, d: 4 }
  #   hash.slice!(:a, :b)  # => {:c=>3, :d=>4}
  #   hash                 # => {:a=>1, :b=>2}
  def slice!: (*untyped keys) -> untyped
  # Removes and returns the key/value pairs matching the given keys.
  #
  #   hash = { a: 1, b: 2, c: 3, d: 4 }
  #   hash.extract!(:a, :b) # => {:a=>1, :b=>2}
  #   hash                  # => {:c=>3, :d=>4}
  def extract!: (*untyped keys) -> untyped
  # A hash is blank if it's empty:
  #
  #   {}.blank?                # => true
  #   { key: 'value' }.blank?  # => false
  #
  # @return [true, false]
  alias blank? empty?
  # Returns a deep copy of hash.
  #
  #   hash = { a: { b: 'b' } }
  #   dup  = hash.deep_dup
  #   dup[:a][:c] = 'c'
  #
  #   hash[:a][:c] # => nil
  #   dup[:a][:c]  # => "c"
  def deep_dup: () -> untyped
  def as_json: (?untyped? options) -> untyped
  # Returns a string representation of the receiver suitable for use as a URL
  # query string:
  #
  #   {name: 'David', nationality: 'Danish'}.to_query
  #   # => "name=David&nationality=Danish"
  #
  # An optional namespace can be passed to enclose key names:
  #
  #   {name: 'David', nationality: 'Danish'}.to_query('user')
  #   # => "user%5Bname%5D=David&user%5Bnationality%5D=Danish"
  #
  # The string pairs "key=value" that conform the query string
  # are sorted lexicographically in ascending order.
  #
  # This method is also aliased as +to_param+.
  def to_query: (?untyped? namespace) -> untyped
  alias to_param to_query
  prepend ActiveSupport::ToJsonWithActiveSupportEncoder
end
