# !!! GENERATED CODE !!!
# Please see generators/rails-generator

module ActiveSupport::Callbacks::ClassMethods
  def normalize_callback_params: (untyped filters, untyped block) -> ::Array[untyped]
  # This is used internally to append, prepend and skip callbacks to the
  # CallbackChain.
  def __update_callbacks: (untyped name) { (untyped, untyped) -> untyped } -> untyped
  # Install a callback for the given event.
  #
  #   set_callback :save, :before, :before_method
  #   set_callback :save, :after,  :after_method, if: :condition
  #   set_callback :save, :around, ->(r, block) { stuff; result = block.call; stuff }
  #
  # The second argument indicates whether the callback is to be run +:before+,
  # +:after+, or +:around+ the event. If omitted, +:before+ is assumed. This
  # means the first example above can also be written as:
  #
  #   set_callback :save, :before_method
  #
  # The callback can be specified as a symbol naming an instance method; as a
  # proc, lambda, or block; or as an object that responds to a certain method
  # determined by the <tt>:scope</tt> argument to +define_callbacks+.
  #
  # If a proc, lambda, or block is given, its body is evaluated in the context
  # of the current object. It can also optionally accept the current object as
  # an argument.
  #
  # Before and around callbacks are called in the order that they are set;
  # after callbacks are called in the reverse order.
  #
  # Around callbacks can access the return value from the event, if it
  # wasn't halted, from the +yield+ call.
  #
  # ===== Options
  #
  # * <tt>:if</tt> - A symbol or an array of symbols, each naming an instance
  #   method or a proc; the callback will be called only when they all return
  #   a true value.
  #
  #   If a proc is given, its body is evaluated in the context of the
  #   current object. It can also optionally accept the current object as
  #   an argument.
  # * <tt>:unless</tt> - A symbol or an array of symbols, each naming an
  #   instance method or a proc; the callback will be called only when they
  #   all return a false value.
  #
  #   If a proc is given, its body is evaluated in the context of the
  #   current object. It can also optionally accept the current object as
  #   an argument.
  # * <tt>:prepend</tt> - If +true+, the callback will be prepended to the
  #   existing chain rather than appended.
  def set_callback: (untyped name, *untyped filter_list) ?{ () -> untyped } -> untyped
  # Skip a previously set callback. Like +set_callback+, <tt>:if</tt> or
  # <tt>:unless</tt> options may be passed in order to control when the
  # callback is skipped.
  #
  #   class Writer < PersonRecord
  #     attr_accessor :age
  #     skip_callback :save, :before, :saving_message, if: -> { age > 18 }
  #   end
  #
  # When if option returns true, callback is skipped.
  #
  #   writer = Writer.new
  #   writer.age = 20
  #   writer.save
  #
  # Output:
  #   - save
  #   saved
  #
  # When if option returns false, callback is NOT skipped.
  #
  #   young_writer = Writer.new
  #   young_writer.age = 17
  #   young_writer.save
  #
  # Output:
  #   saving...
  #   - save
  #   saved
  #
  # An <tt>ArgumentError</tt> will be raised if the callback has not
  # already been set (unless the <tt>:raise</tt> option is set to <tt>false</tt>).
  def skip_callback: (untyped name, *untyped filter_list) ?{ () -> untyped } -> untyped
  # Remove all set callbacks for the given event.
  def reset_callbacks: (untyped name) -> untyped
  # Define sets of events in the object life cycle that support callbacks.
  #
  #   define_callbacks :validate
  #   define_callbacks :initialize, :save, :destroy
  #
  # ===== Options
  #
  # * <tt>:terminator</tt> - Determines when a before filter will halt the
  #   callback chain, preventing following before and around callbacks from
  #   being called and the event from being triggered.
  #   This should be a lambda to be executed.
  #   The current object and the result lambda of the callback will be provided
  #   to the terminator lambda.
  #
  #     define_callbacks :validate, terminator: ->(target, result_lambda) { result_lambda.call == false }
  #
  #   In this example, if any before validate callbacks returns +false+,
  #   any successive before and around callback is not executed.
  #
  #   The default terminator halts the chain when a callback throws +:abort+.
  #
  # * <tt>:skip_after_callbacks_if_terminated</tt> - Determines if after
  #   callbacks should be terminated by the <tt>:terminator</tt> option. By
  #   default after callbacks are executed no matter if callback chain was
  #   terminated or not. This option has no effect if <tt>:terminator</tt>
  #   option is set to +nil+.
  #
  # * <tt>:scope</tt> - Indicates which methods should be executed when an
  #   object is used as a callback.
  #
  #     class Audit
  #       def before(caller)
  #         puts 'Audit: before is called'
  #       end
  #
  #       def before_save(caller)
  #         puts 'Audit: before_save is called'
  #       end
  #     end
  #
  #     class Account
  #       include ActiveSupport::Callbacks
  #
  #       define_callbacks :save
  #       set_callback :save, :before, Audit.new
  #
  #       def save
  #         run_callbacks :save do
  #           puts 'save in main'
  #         end
  #       end
  #     end
  #
  #   In the above case whenever you save an account the method
  #   <tt>Audit#before</tt> will be called. On the other hand
  #
  #     define_callbacks :save, scope: [:kind, :name]
  #
  #   would trigger <tt>Audit#before_save</tt> instead. That's constructed
  #   by calling <tt>#{kind}_#{name}</tt> on the given instance. In this
  #   case "kind" is "before" and "name" is "save". In this context +:kind+
  #   and +:name+ have special meanings: +:kind+ refers to the kind of
  #   callback (before/after/around) and +:name+ refers to the method on
  #   which callbacks are being defined.
  #
  #   A declaration like
  #
  #     define_callbacks :save, scope: [:name]
  #
  #   would call <tt>Audit#save</tt>.
  #
  # ===== Notes
  #
  # +names+ passed to +define_callbacks+ must not end with
  # <tt>!</tt>, <tt>?</tt> or <tt>=</tt>.
  #
  # Calling +define_callbacks+ multiple times with the same +names+ will
  # overwrite previous callbacks registered with +set_callback+.
  def define_callbacks: (*untyped names) -> untyped
  def get_callbacks: (untyped name) -> untyped
  def set_callbacks: (untyped name, untyped callbacks) -> untyped
end
