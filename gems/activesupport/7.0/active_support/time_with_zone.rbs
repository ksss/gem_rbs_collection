# !!! GENERATED CODE !!!
# Please see generators/rails-generator

class ActiveSupport::TimeWithZone
  # Report class name as 'Time' to thwart type checking.
  def self.name: () -> "Time"
  def initialize: (untyped utc_time, untyped time_zone, ?untyped? local_time, ?untyped? period) -> void
  # Returns a <tt>Time</tt> instance that represents the time in +time_zone+.
  def time: () -> untyped
  def utc: () -> ::Time
  alias comparable_time utc
  def getgm: () -> ::Time
  def getutc: () -> ::Time
  def gmtime: () -> ::Time
  # Returns the underlying <tt>TZInfo::TimezonePeriod</tt>.
  def period: () -> untyped
  def in_time_zone: (?::ActiveSupport::TimeZone | ::String new_zone) -> ::ActiveSupport::TimeWithZone
                  | (false? zone) -> self
  def localtime: (?::String utc_offset) -> ::Time
  def getlocal: (?::Integer utc_offset) -> self
  def dst?: () -> bool
  def isdst: () -> bool
  def utc?: () -> bool
  def gmt?: () -> bool
  def utc_offset: () -> ::Integer
  def gmt_offset: () -> ::Integer
  def gmtoff: () -> ::Integer
  def formatted_offset: (?bool colon, ?untyped? alternate_utc_string) -> untyped
  def zone: () -> ::String
  def inspect: () -> ::String
  def xmlschema: (?::Integer fraction_digits) -> ::String
  alias iso8601 xmlschema
  alias rfc3339 xmlschema
  def as_json: (*untyped) -> ::Hash[::String, ::String | ::Integer]
  def init_with: (untyped coder) -> untyped
  def encode_with: (untyped coder) -> untyped
  def httpdate: () -> ::String
  def rfc2822: () -> ::String
  alias rfc822 rfc2822
  def to_s: () -> ::String
  def to_fs: (?::Symbol format) -> untyped
  alias to_formatted_s to_fs
  def strftime: (::String arg0) -> ::String
  def <=>: (::Time other) -> ::Integer
         | (untyped other) -> ::Integer?
  alias before? <
  alias after? >
  # Returns true if the current object's time is within the specified
  # +min+ and +max+ time.
  def between?: (untyped min, untyped max) -> untyped
  # Returns true if the current object's time is in the past.
  def past?: () -> untyped
  # Returns true if the current object's time falls within
  # the current day.
  def today?: () -> untyped
  # Returns true if the current object's time falls within
  # the next day (tomorrow).
  def tomorrow?: () -> untyped
  alias next_day? tomorrow?
  # Returns true if the current object's time falls within
  # the previous day (yesterday).
  def yesterday?: () -> untyped
  alias prev_day? yesterday?
  # Returns true if the current object's time is in the future.
  def future?: () -> untyped
  def eql?: (untyped arg0) -> bool
  def hash: () -> ::Integer
  def +: (::ActiveSupport::Duration other) -> self
       | (::Numeric arg0) -> self
       | (::ActiveSupport::Duration other) -> self
  def since: (untyped seconds) -> untyped
  alias in since
  def -: (::ActiveSupport::Duration other) -> self
       | (::Time arg0) -> ::Float
       | (::Numeric arg0) -> self
       | (self other) -> ::Float
       | (::ActiveSupport::Duration other) -> self
  def ago: (untyped other) -> self
  def change: (untyped options) -> self
  def advance: (untyped options) -> self
  def to_a: () -> [ ::Integer, ::Integer, ::Integer, ::Integer, ::Integer, ::Integer, ::Integer, ::Integer, bool, ::String ]
  def to_f: () -> ::Float
  def to_i: () -> ::Integer
  def tv_sec: () -> ::Integer
  def to_r: () -> ::Rational
  def to_datetime: () -> ::DateTime
  def to_time: () -> self
  def acts_like_time?: () -> true
  # Say we're a Time to thwart type checking.
  def is_a?: (untyped klass) -> untyped
  alias kind_of? is_a?
  def blank?: () -> false
  def freeze: () -> untyped
  def marshal_dump: () -> ::Array[untyped]
  def marshal_load: (untyped variables) -> untyped
  # respond_to_missing? is not called in some cases, such as when type conversion is
  # performed with Kernel#String
  def respond_to?: (untyped sym, ?bool include_priv) -> (false | untyped)
  # Ensure proxy class responds to all methods that underlying time instance
  # responds to.
  def respond_to_missing?: (untyped sym, untyped include_priv) -> (false | untyped)
  # Send the missing method to +time+ instance, and wrap result in a new
  # TimeWithZone with the existing +time_zone+.
  def method_missing: (untyped sym, *untyped args) ?{ () -> untyped } -> untyped
  private def incorporate_utc_offset: (untyped time, untyped offset) -> untyped
  private def get_period_and_ensure_valid_local_time: (untyped period) -> untyped
  private def transfer_time_values_to_utc_constructor: (untyped time) -> untyped
  private def duration_of_variable_length?: (untyped obj) -> untyped
  private def wrap_with_time_zone: (untyped time) -> (untyped | ::Range[untyped] | untyped)
  include Comparable
  include DateAndTime::Compatibility
  attr_reader time_zone: untyped
  include ::Comparable
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations
  include ::DateAndTime::Compatibility
  def to_json: (?::JSON::State state) -> ::String
  def <: (::Time arg0) -> bool
  def <=: (::Time arg0) -> bool
  def >: (::Time arg0) -> bool
  def >=: (::Time arg0) -> bool
  def asctime: () -> ::String
  def ctime: () -> ::String
  def day: () -> ::Integer
  def friday?: () -> bool
  def hour: () -> ::Integer
  def mday: () -> ::Integer
  def min: () -> ::Integer
  def mon: () -> ::Integer
  def monday?: () -> bool
  def nsec: () -> ::Integer
  def round: (?::Integer arg0) -> self
  def saturday?: () -> bool
  def sec: () -> ::Integer
  def subsec: () -> (0 | ::Rational)
  def sunday?: () -> bool
  def thursday?: () -> bool
  def tuesday?: () -> bool
  def tv_nsec: () -> ::Integer
  def tv_usec: () -> ::Integer
  def usec: () -> ::Integer
  def wday: () -> ::Integer
  def wednesday?: () -> bool
  def yday: () -> ::Integer
  def year: () -> ::Integer
  def month: () -> ::Integer
  def floor: (?::Integer ndigits) -> self
  def ceil: (?::Integer ndigits) -> self
  def to_date: () -> ::Date
  def seconds_since_midnight: () -> ::Float
  def seconds_until_end_of_day: () -> ::Integer
  def sec_fraction: () -> (::Integer | ::Rational)
  def beginning_of_day: () -> self
  alias midnight beginning_of_day
  alias at_midnight beginning_of_day
  alias at_beginning_of_day beginning_of_day
  def middle_of_day: () -> self
  alias midday middle_of_day
  alias noon middle_of_day
  alias at_midday middle_of_day
  alias at_noon middle_of_day
  alias at_middle_of_day middle_of_day
  def end_of_day: () -> self
  alias at_end_of_day end_of_day
  def beginning_of_hour: () -> self
  alias at_beginning_of_hour beginning_of_hour
  def end_of_hour: () -> self
  alias at_end_of_hour end_of_hour
  def beginning_of_minute: () -> self
  alias at_beginning_of_minute beginning_of_minute
  def end_of_minute: () -> self
  alias at_end_of_minute end_of_minute
  def plus_with_duration: (untyped other) -> untyped
  def plus_without_duration: (::Time | self arg0) -> ::Float
                           | (::Numeric arg0) -> self
  def minus_with_duration: (::Time | self arg0) -> ::Float
                         | (::Numeric arg0) -> self
  def minus_without_duration: (::Time | self arg0) -> ::Float
                            | (::Numeric arg0) -> self
  def minus_with_coercion: (::Time | self arg0) -> ::Float
                         | (::Numeric arg0) -> self
  def minus_without_coercion: (::Time | self arg0) -> ::Float
                            | (::Numeric arg0) -> self
  def compare_with_coercion: (untyped other) -> (-1 | 0 | 1 | nil)
  def compare_without_coercion: (untyped other) -> (-1 | 0 | 1 | nil)
  def eql_with_coercion: (untyped other) -> bool
  def eql_without_coercion: (untyped other) -> bool
  def prev_day: () -> self
  def next_day: () -> self
  def prev_month: () -> self
  def next_month: () -> self
  def prev_year: () -> self
  def next_year: () -> self
  alias to_default_s to_s
  NOT_SET: Object
  PRECISIONS: Hash[Integer, String]
  SECONDS_PER_DAY: Integer
end
