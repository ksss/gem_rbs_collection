# !!! GENERATED CODE !!!
# Please see generators/rails-generator

class ActiveSupport::TimeZone
  # Assumes self represents an offset from UTC in seconds (as returned from
  # Time#utc_offset) and turns this into an +HH:MM formatted string.
  #
  #   ActiveSupport::TimeZone.seconds_to_utc_offset(-21_600) # => "-06:00"
  def self.seconds_to_utc_offset: (untyped seconds, ?bool colon) -> untyped
  def self.find_tzinfo: (untyped name) -> untyped
  alias self.create self.new
  # Returns a TimeZone instance with the given name, or +nil+ if no
  # such TimeZone instance exists. (This exists to support the use of
  # this class with the +composed_of+ macro.)
  def self.new: (untyped name) -> untyped
  # Returns an array of all TimeZone objects. There are multiple
  # TimeZone objects per time zone, in many cases, to make it easier
  # for users to find their own time zone.
  def self.all: () -> untyped
  # Locate a specific time zone object. If the argument is a string, it
  # is interpreted to mean the name of the timezone to locate. If it is a
  # numeric value it is either the hour offset, or the second offset, of the
  # timezone to find. (The first one with that offset will be returned.)
  # Returns +nil+ if no such time zone is known to the system.
  def self.[]: (untyped arg) -> untyped
  # A convenience method for returning a collection of TimeZone objects
  # for time zones in the USA.
  def self.us_zones: () -> untyped
  # A convenience method for returning a collection of TimeZone objects
  # for time zones in the country specified by its ISO 3166-1 Alpha2 code.
  def self.country_zones: (untyped country_code) -> untyped
  def self.clear: () -> untyped
  private def self.load_country_zones: (untyped code) -> untyped
  private def self.zones_map: () -> untyped
  # Create a new TimeZone object with the given name and offset. The
  # offset is the number of seconds that this time zone is offset from UTC
  # (GMT). Seconds were chosen as the offset unit because that is the unit
  # that Ruby uses to represent time zone offsets (see Time#utc_offset).
  def initialize: (untyped name, ?untyped? utc_offset, ?untyped? tzinfo) -> void
  # Returns the offset of this time zone from UTC in seconds.
  def utc_offset: () -> untyped
  # Returns a formatted string of the offset from UTC, or an alternative
  # string if the time zone is already UTC.
  #
  #   zone = ActiveSupport::TimeZone['Central Time (US & Canada)']
  #   zone.formatted_offset        # => "-06:00"
  #   zone.formatted_offset(false) # => "-0600"
  def formatted_offset: (?bool colon, ?untyped? alternate_utc_string) -> untyped
  # Compare this time zone to the parameter. The two are compared first on
  # their offsets, and then by name.
  def <=>: (untyped zone) -> (nil | untyped)
  # Compare #name and TZInfo identifier to a supplied regexp, returning +true+
  # if a match is found.
  def =~: (untyped re) -> untyped
  # Compare #name and TZInfo identifier to a supplied regexp, returning +true+
  # if a match is found.
  def match?: (untyped re) -> untyped
  # Returns a textual representation of this time zone.
  def to_s: () -> ::String
  # Method for creating new ActiveSupport::TimeWithZone instance in time zone
  # of +self+ from given values.
  #
  #   Time.zone = 'Hawaii'                    # => "Hawaii"
  #   Time.zone.local(2007, 2, 1, 15, 30, 45) # => Thu, 01 Feb 2007 15:30:45 HST -10:00
  def local: (*untyped args) -> untyped
  # Method for creating new ActiveSupport::TimeWithZone instance in time zone
  # of +self+ from number of seconds since the Unix epoch.
  #
  #   Time.zone = 'Hawaii'        # => "Hawaii"
  #   Time.utc(2000).to_f         # => 946684800.0
  #   Time.zone.at(946684800.0)   # => Fri, 31 Dec 1999 14:00:00 HST -10:00
  #
  # A second argument can be supplied to specify sub-second precision.
  #
  #   Time.zone = 'Hawaii'                # => "Hawaii"
  #   Time.at(946684800, 123456.789).nsec # => 123456789
  def at: (*untyped args) -> untyped
  # Method for creating new ActiveSupport::TimeWithZone instance in time zone
  # of +self+ from an ISO 8601 string.
  #
  #   Time.zone = 'Hawaii'                     # => "Hawaii"
  #   Time.zone.iso8601('1999-12-31T14:00:00') # => Fri, 31 Dec 1999 14:00:00 HST -10:00
  #
  # If the time components are missing then they will be set to zero.
  #
  #   Time.zone = 'Hawaii'            # => "Hawaii"
  #   Time.zone.iso8601('1999-12-31') # => Fri, 31 Dec 1999 00:00:00 HST -10:00
  #
  # If the string is invalid then an +ArgumentError+ will be raised unlike +parse+
  # which usually returns +nil+ when given an invalid date string.
  def iso8601: (untyped str) -> untyped
  # Method for creating new ActiveSupport::TimeWithZone instance in time zone
  # of +self+ from parsed string.
  #
  #   Time.zone = 'Hawaii'                   # => "Hawaii"
  #   Time.zone.parse('1999-12-31 14:00:00') # => Fri, 31 Dec 1999 14:00:00 HST -10:00
  #
  # If upper components are missing from the string, they are supplied from
  # TimeZone#now:
  #
  #   Time.zone.now               # => Fri, 31 Dec 1999 14:00:00 HST -10:00
  #   Time.zone.parse('22:30:00') # => Fri, 31 Dec 1999 22:30:00 HST -10:00
  #
  # However, if the date component is not provided, but any other upper
  # components are supplied, then the day of the month defaults to 1:
  #
  #   Time.zone.parse('Mar 2000') # => Wed, 01 Mar 2000 00:00:00 HST -10:00
  #
  # If the string is invalid then an +ArgumentError+ could be raised.
  def parse: (untyped str, ?untyped now) -> untyped
  # Method for creating new ActiveSupport::TimeWithZone instance in time zone
  # of +self+ from an RFC 3339 string.
  #
  #   Time.zone = 'Hawaii'                     # => "Hawaii"
  #   Time.zone.rfc3339('2000-01-01T00:00:00Z') # => Fri, 31 Dec 1999 14:00:00 HST -10:00
  #
  # If the time or zone components are missing then an +ArgumentError+ will
  # be raised. This is much stricter than either +parse+ or +iso8601+ which
  # allow for missing components.
  #
  #   Time.zone = 'Hawaii'            # => "Hawaii"
  #   Time.zone.rfc3339('1999-12-31') # => ArgumentError: invalid date
  def rfc3339: (untyped str) -> untyped
  # Parses +str+ according to +format+ and returns an ActiveSupport::TimeWithZone.
  #
  # Assumes that +str+ is a time in the time zone +self+,
  # unless +format+ includes an explicit time zone.
  # (This is the same behavior as +parse+.)
  # In either case, the returned TimeWithZone has the timezone of +self+.
  #
  #   Time.zone = 'Hawaii'                   # => "Hawaii"
  #   Time.zone.strptime('1999-12-31 14:00:00', '%Y-%m-%d %H:%M:%S') # => Fri, 31 Dec 1999 14:00:00 HST -10:00
  #
  # If upper components are missing from the string, they are supplied from
  # TimeZone#now:
  #
  #   Time.zone.now                              # => Fri, 31 Dec 1999 14:00:00 HST -10:00
  #   Time.zone.strptime('22:30:00', '%H:%M:%S') # => Fri, 31 Dec 1999 22:30:00 HST -10:00
  #
  # However, if the date component is not provided, but any other upper
  # components are supplied, then the day of the month defaults to 1:
  #
  #   Time.zone.strptime('Mar 2000', '%b %Y') # => Wed, 01 Mar 2000 00:00:00 HST -10:00
  def strptime: (untyped str, untyped format, ?untyped now) -> untyped
  def now: () -> ActiveSupport::TimeWithZone
  # Returns the current date in this time zone.
  def today: () -> untyped
  # Returns the next date in this time zone.
  def tomorrow: () -> untyped
  # Returns the previous date in this time zone.
  def yesterday: () -> untyped
  # Adjust the given time to the simultaneous time in the time zone
  # represented by +self+. Returns a local time with the appropriate offset
  # -- if you want an ActiveSupport::TimeWithZone instance, use
  # Time#in_time_zone() instead.
  #
  # As of tzinfo 2, utc_to_local returns a Time with a non-zero utc_offset.
  # See the +utc_to_local_returns_utc_offset_times+ config for more info.
  def utc_to_local: (untyped time) -> untyped
  # Adjust the given time to the simultaneous time in UTC. Returns a
  # Time.utc() instance.
  def local_to_utc: (untyped time, ?bool dst) -> untyped
  # Available so that TimeZone instances respond like <tt>TZInfo::Timezone</tt>
  # instances.
  def period_for_utc: (untyped time) -> untyped
  # Available so that TimeZone instances respond like <tt>TZInfo::Timezone</tt>
  # instances.
  def period_for_local: (untyped time, ?bool dst) -> untyped
  def periods_for_local: (untyped time) -> untyped
  def init_with: (untyped coder) -> untyped
  def encode_with: (untyped coder) -> untyped
  private def parts_to_time: (untyped parts, untyped now) -> (nil | untyped)
  private def time_now: () -> untyped
  include Comparable
  attr_reader name: untyped
  attr_reader tzinfo: untyped
  MAPPING: Hash[String, String]
end
